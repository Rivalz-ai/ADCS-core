{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/IPeripheryPayments.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\n/// @title Periphery Payments\n/// @notice Functions to ease deposits and withdrawals of ETH\ninterface IPeripheryPayments {\n    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.\n    /// @param amountMinimum The minimum amount of WETH9 to unwrap\n    /// @param recipient The address receiving ETH\n    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;\n\n    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\n    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\n    /// that use ether for the input amount\n    function refundETH() external payable;\n\n    /// @notice Transfers the full amount of a token held by this contract to recipient\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\n    /// @param token The contract address of the token which will be transferred to `recipient`\n    /// @param amountMinimum The minimum amount of token required for a transfer\n    /// @param recipient The destination address of the token\n    function sweepToken(\n        address token,\n        uint256 amountMinimum,\n        address recipient\n    ) external payable;\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "src/ADCSConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./interfaces/IADCSCoordinator.sol\";\n\nabstract contract ADCSConsumerBase {\n    using ADCS for ADCS.Request;\n\n    struct StringAndBool {\n        string name;\n        bool response;\n    }\n    error OnlyCoordinatorCanFulfill(address have, address want);\n    mapping(bytes32 => bytes4) private sTypeIdToFunctionSelector;\n    IADCSCoordinator public immutable COORDINATOR;\n\n    /**\n     * @param _adcsResponseCoordinator address of ADCSCoordinator contract\n     */\n    constructor(address _adcsResponseCoordinator) {\n        COORDINATOR = IADCSCoordinator(_adcsResponseCoordinator);\n\n        sTypeIdToFunctionSelector[keccak256(abi.encodePacked(\"uint256\"))] = COORDINATOR\n            .fulfillDataRequestUint256\n            .selector;\n        sTypeIdToFunctionSelector[keccak256(abi.encodePacked(\"bool\"))] = COORDINATOR\n            .fulfillDataRequestBool\n            .selector;\n        sTypeIdToFunctionSelector[keccak256(abi.encodePacked(\"bytes32\"))] = COORDINATOR\n            .fulfillDataRequestBytes32\n            .selector;\n        sTypeIdToFunctionSelector[keccak256(abi.encodePacked(\"bytes\"))] = COORDINATOR\n            .fulfillDataRequestBytes\n            .selector;\n\n        sTypeIdToFunctionSelector[keccak256(abi.encodePacked(\"stringAndbool\"))] = COORDINATOR\n            .fulfillDataRequestStringAndBool\n            .selector;\n    }\n\n    /**\n     * @notice Build a request using the Orakl library\n     * @param jobId the job specification ID that the request is created for\n     * @param typeId the reponse type ID that the request is created for\n     * @return req request in memory\n     */\n    function buildRequest(\n        bytes32 jobId,\n        bytes32 typeId\n    ) internal view returns (ADCS.Request memory req) {\n        return req.initialize(jobId, address(COORDINATOR), sTypeIdToFunctionSelector[typeId]);\n    }\n\n    modifier verifyRawFulfillment() {\n        address coordinatorAddress = address(COORDINATOR);\n        if (msg.sender != coordinatorAddress) {\n            revert OnlyCoordinatorCanFulfill(msg.sender, coordinatorAddress);\n        }\n        _;\n    }\n}\n"
    },
    "src/ADCSConsumerFulfill.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./ADCSConsumerBase.sol\";\n\nabstract contract ADCSConsumerFulfillUint256 is ADCSConsumerBase {\n    function fulfillDataRequest(uint256 requestId, uint256 response) internal virtual;\n\n    function rawFulfillDataRequest(\n        uint256 requestId,\n        uint256 response\n    ) external verifyRawFulfillment {\n        fulfillDataRequest(requestId, response);\n    }\n}\n\nabstract contract ADCSConsumerFulfillBool is ADCSConsumerBase {\n    function fulfillDataRequest(uint256 requestId, bool response) internal virtual;\n\n    function rawFulfillDataRequest(uint256 requestId, bool response) external verifyRawFulfillment {\n        fulfillDataRequest(requestId, response);\n    }\n}\n\nabstract contract ADCSConsumerFulfillBytes32 is ADCSConsumerBase {\n    function fulfillDataRequest(uint256 requestId, bytes32 response) internal virtual;\n\n    function rawFulfillDataRequest(\n        uint256 requestId,\n        bytes32 response\n    ) external verifyRawFulfillment {\n        fulfillDataRequest(requestId, response);\n    }\n}\n\nabstract contract ADCSConsumerFulfillBytes is ADCSConsumerBase {\n    function fulfillDataRequest(uint256 requestId, bytes memory response) internal virtual;\n\n    function rawFulfillDataRequest(\n        uint256 requestId,\n        bytes memory response\n    ) external verifyRawFulfillment {\n        fulfillDataRequest(requestId, response);\n    }\n}\n\nabstract contract ADCSConsumerFulfillStringAndBool is ADCSConsumerBase {\n    function fulfillDataRequest(uint256 requestId, StringAndBool memory response) internal virtual;\n\n    function rawFulfillDataRequest(\n        uint256 requestId,\n        StringAndBool memory response\n    ) external verifyRawFulfillment {\n        fulfillDataRequest(requestId, response);\n    }\n}\n"
    },
    "src/ADCSCoordinator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"./interfaces/ITypeAndVersion.sol\";\nimport \"./interfaces/IADCSCoordinatorBase.sol\";\nimport \"./ADCSConsumerFulfill.sol\";\nimport \"./CoordinatorBase.sol\";\nimport \"./libraries/ADCS.sol\";\n\ncontract ADCSCoordinator is CoordinatorBase, IADCSCoordinatorBase, ITypeAndVersion {\n    uint8 public constant MAX_ORACLES = 255;\n\n    using ADCS for ADCS.Request;\n\n    struct Submission {\n        address[] oracles; // oracles that submitted response\n        mapping(address => bool) submitted;\n    }\n\n    /* requestId */\n    /* submission details */\n    mapping(uint256 => Submission) sSubmission;\n\n    /* oracle */\n    /* registration status */\n    mapping(address => bool) private sIsOracleRegistered;\n\n    mapping(address => uint64) private sConsumerToNonce;\n\n    error TooManyOracles();\n    error UnregisteredOracleFulfillment(address oracle);\n    error InvalidJobId();\n    error InvalidNumSubmission();\n    error OracleAlreadySubmitted();\n    error IncompatibleJobId();\n\n    event OracleRegistered(address oracle);\n    event OracleDeregistered(address oracle);\n    event PrepaymentSet(address prepayment);\n    event DataRequested(\n        uint256 indexed requestId,\n        uint32 callbackGasLimit,\n        address indexed sender,\n        bytes32 jobId,\n        uint256 blockNumber,\n        bytes data\n    );\n    event DataRequestFulfilledUint256(uint256 indexed requestId, uint256 response, bool success);\n    event DataRequestFulfilledBool(uint256 indexed requestId, bool response, bool success);\n    event DataRequestFulfilledBytes32(uint256 indexed requestId, bytes32 response, bool success);\n    event DataRequestFulfilledBytes(uint256 indexed requestId, bytes response, bool success);\n    event DataRequestFulfilledStringAndBool(\n        uint256 indexed requestId,\n        StringAndBool response,\n        bool success\n    );\n\n    event DataRequestFulfilled(uint256 indexed requestId, bytes response, bool success);\n\n    event DataSubmitted(address oracle, uint256 requestId);\n\n    constructor() {}\n\n    /**\n     * @notice Register an oracle\n     * @param oracle address of the oracle\n     */\n    function registerOracle(address oracle) external onlyOwner {\n        if (sOracles.length >= MAX_ORACLES) {\n            revert TooManyOracles();\n        }\n\n        if (sIsOracleRegistered[oracle]) {\n            revert OracleAlreadyRegistered(oracle);\n        }\n        sOracles.push(oracle);\n        sIsOracleRegistered[oracle] = true;\n        emit OracleRegistered(oracle);\n    }\n\n    /**\n     * @notice Deregister an oracle\n     * @param oracle address of the oracle\n     */\n    function deregisterOracle(address oracle) external onlyOwner {\n        if (!sIsOracleRegistered[oracle]) {\n            revert NoSuchOracle(oracle);\n        }\n        delete sIsOracleRegistered[oracle];\n\n        uint256 oraclesLength = sOracles.length;\n        for (uint256 i = 0; i < oraclesLength; ++i) {\n            if (sOracles[i] == oracle) {\n                address last = sOracles[oraclesLength - 1];\n                sOracles[i] = last;\n                sOracles.pop();\n                break;\n            }\n        }\n\n        emit OracleDeregistered(oracle);\n    }\n\n    /**\n     * @notice The type and version of this contract\n     * @return Type and version string\n     */\n    function typeAndVersion() external pure virtual override returns (string memory) {\n        return \"ADCSCoordinator v0.1\";\n    }\n\n    /**\n     * @notice Find out whether given oracle address was registered.\n     * @return true when oracle address registered, otherwise false\n     */\n    function isOracleRegistered(address oracle) external view returns (bool) {\n        return sIsOracleRegistered[oracle];\n    }\n\n    function computeRequestId(address sender, uint64 nonce) private pure returns (uint256) {\n        return uint256(keccak256(abi.encode(sender, nonce)));\n    }\n\n    function pendingRequestExists(address consumer, uint64 nonce) public view returns (bool) {\n        uint256 oraclesLength = sOracles.length;\n        for (uint256 i = 0; i < oraclesLength; ++i) {\n            uint256 requestId = computeRequestId(consumer, nonce);\n            if (isValidRequestId(requestId)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function increaseNonce(address consumer) private returns (uint64) {\n        uint64 nonce = sConsumerToNonce[consumer] + 1;\n        sConsumerToNonce[consumer] = nonce;\n        return nonce;\n    }\n\n    function requestData(\n        uint32 callbackGasLimit,\n        ADCS.Request memory req\n    ) external returns (uint256) {\n        if (callbackGasLimit > sConfig.maxGasLimit) {\n            revert GasLimitTooBig(callbackGasLimit, sConfig.maxGasLimit);\n        }\n        uint64 nonce = increaseNonce(msg.sender);\n        uint256 requestId = computeRequestId(msg.sender, nonce);\n        uint256 blockNumber = block.number;\n        sRequestIdToCommitment[requestId] = computeCommitment(\n            requestId,\n            blockNumber,\n            callbackGasLimit,\n            msg.sender,\n            req.id\n        );\n\n        sRequestOwner[requestId] = msg.sender;\n\n        emit DataRequested(\n            requestId,\n            callbackGasLimit,\n            msg.sender,\n            req.id,\n            blockNumber,\n            req.buf.buf\n        );\n\n        return requestId;\n    }\n\n    function validateDataResponse(RequestCommitment memory rc, uint256 requestId) private view {\n        if (!sIsOracleRegistered[msg.sender]) {\n            revert UnregisteredOracleFulfillment(msg.sender);\n        }\n\n        if (sSubmission[requestId].submitted[msg.sender]) {\n            revert OracleAlreadySubmitted();\n        }\n\n        bytes32 commitment = sRequestIdToCommitment[requestId];\n        if (commitment == 0) {\n            revert NoCorrespondingRequest();\n        }\n\n        if (\n            commitment !=\n            computeCommitment(requestId, rc.blockNum, rc.callbackGasLimit, rc.sender, rc.jobId)\n        ) {\n            revert IncorrectCommitment();\n        }\n    }\n\n    function fulfill(bytes memory resp, RequestCommitment memory rc) private returns (bool) {\n        // Call with explicitly the amount of callback gas requested\n        // Important to not let them exhaust the gas budget and avoid oracle payment.\n        // Do not allow any non-view/non-pure coordinator functions to be called\n        // during the consumers callback code via reentrancyLock.\n        // Note that callWithExactGas will revert if we do not have sufficient gas\n        // to give the callee their requested amount.\n        sConfig.reentrancyLock = true;\n        bool success = callWithExactGas(rc.callbackGasLimit, rc.sender, resp);\n        //\n        sConfig.reentrancyLock = false;\n        return success;\n    }\n\n    function cleanupAfterFulfillment(uint256 requestId) private returns (address[] memory) {\n        address[] memory oracles = sSubmission[requestId].oracles;\n\n        for (uint8 i = 0; i < oracles.length; ++i) {\n            delete sSubmission[requestId].submitted[oracles[i]];\n        }\n\n        delete sSubmission[requestId];\n        delete sRequestIdToCommitment[requestId];\n        delete sRequestOwner[requestId];\n\n        return oracles;\n    }\n\n    function uint256ToInt256(uint256[] memory arr) private pure returns (int256[] memory) {\n        int256[] memory responses = new int256[](arr.length);\n        for (uint256 i = 0; i < arr.length; i++) {\n            responses[i] = int256(uint256(arr[i]));\n        }\n        return responses;\n    }\n\n    function computeCommitment(\n        uint256 requestId,\n        uint256 blockNumber,\n        uint32 callbackGasLimit,\n        address sender,\n        bytes32 jobId\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(requestId, blockNumber, callbackGasLimit, sender, jobId));\n    }\n\n    function fulfillDataRequestUint256(\n        uint256 requestId,\n        uint256 response,\n        RequestCommitment memory rc\n    ) external nonReentrant {\n        validateDataResponse(rc, requestId);\n        sSubmission[requestId].submitted[msg.sender] = true;\n\n        address[] storage oracles = sSubmission[requestId].oracles;\n        oracles.push(msg.sender);\n        bytes memory resp = abi.encodeWithSelector(\n            ADCSConsumerFulfillUint256.rawFulfillDataRequest.selector,\n            requestId,\n            response\n        );\n        bool success = fulfill(resp, rc);\n        cleanupAfterFulfillment(requestId);\n\n        emit DataRequestFulfilledUint256(requestId, response, success);\n    }\n\n    function fulfillDataRequestBool(\n        uint256 requestId,\n        bool response,\n        RequestCommitment memory rc\n    ) external override {\n        validateDataResponse(rc, requestId);\n        sSubmission[requestId].submitted[msg.sender] = true;\n\n        address[] storage oracles = sSubmission[requestId].oracles;\n        oracles.push(msg.sender);\n        bytes memory resp = abi.encodeWithSelector(\n            ADCSConsumerFulfillBool.rawFulfillDataRequest.selector,\n            requestId,\n            response\n        );\n        bool success = fulfill(resp, rc);\n        cleanupAfterFulfillment(requestId);\n\n        emit DataRequestFulfilledBool(requestId, response, success);\n    }\n\n    function fulfillDataRequestBytes32(\n        uint256 requestId,\n        bytes32 response,\n        RequestCommitment memory rc\n    ) external override {\n        validateDataResponse(rc, requestId);\n        sSubmission[requestId].submitted[msg.sender] = true;\n\n        address[] storage oracles = sSubmission[requestId].oracles;\n        oracles.push(msg.sender);\n        bytes memory resp = abi.encodeWithSelector(\n            ADCSConsumerFulfillBytes32.rawFulfillDataRequest.selector,\n            requestId,\n            response\n        );\n        bool success = fulfill(resp, rc);\n        cleanupAfterFulfillment(requestId);\n\n        emit DataRequestFulfilledBytes32(requestId, response, success);\n    }\n\n    function fulfillDataRequestBytes(\n        uint256 requestId,\n        bytes memory response,\n        RequestCommitment memory rc\n    ) external override {\n        validateDataResponse(rc, requestId);\n        sSubmission[requestId].submitted[msg.sender] = true;\n\n        address[] storage oracles = sSubmission[requestId].oracles;\n        oracles.push(msg.sender);\n        bytes memory resp = abi.encodeWithSelector(\n            ADCSConsumerFulfillBytes.rawFulfillDataRequest.selector,\n            requestId,\n            response\n        );\n        bool success = fulfill(resp, rc);\n        cleanupAfterFulfillment(requestId);\n\n        emit DataRequestFulfilledBytes(requestId, response, success);\n    }\n\n    function fulfillDataRequestStringAndBool(\n        uint256 requestId,\n        StringAndBool memory response,\n        RequestCommitment memory rc\n    ) external override {\n        validateDataResponse(rc, requestId);\n        bytes memory resp = abi.encodeWithSelector(\n            ADCSConsumerFulfillStringAndBool.rawFulfillDataRequest.selector,\n            requestId,\n            response\n        );\n        bool success = fulfill(resp, rc);\n        emit DataRequestFulfilledStringAndBool(requestId, response, success);\n    }\n}\n"
    },
    "src/CoordinatorBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/ICoordinatorBase.sol\";\n\nabstract contract CoordinatorBase is Ownable, ICoordinatorBase {\n    // 5k is plenty for an EXTCODESIZE call (2600) + warm CALL (100)\n    // and some arithmetic operations.\n    uint256 private constant GAS_FOR_CALL_EXACT_CHECK = 5_000;\n\n    address[] public sOracles;\n\n    /* requestID */\n    /* commitment */\n    mapping(uint256 => bytes32) internal sRequestIdToCommitment;\n\n    /* requestID */\n    /* owner */\n    mapping(uint256 => address) internal sRequestOwner;\n\n    struct Config {\n        uint32 maxGasLimit;\n        bool reentrancyLock;\n        // Gas to cover oracle payment after we calculate the payment.\n        // We make it configurable in case those operations are repriced.\n        uint32 gasAfterPaymentCalculation;\n    }\n    Config internal sConfig;\n\n    error Reentrant();\n    error NoCorrespondingRequest();\n    error NotRequestOwner();\n    error OracleAlreadyRegistered(address oracle);\n    error NoSuchOracle(address oracle);\n    error RefundFailure();\n    error InvalidConsumer(uint64 accId, address consumer);\n    error IncorrectCommitment();\n    error GasLimitTooBig(uint32 have, uint32 want);\n    error InsufficientPayment(uint256 have, uint256 want);\n\n    event ConfigSet(uint32 maxGasLimit, uint32 gasAfterPaymentCalculation);\n    event RequestCanceled(uint256 indexed requestId);\n\n    constructor() Ownable(_msgSender()) {}\n\n    modifier nonReentrant() {\n        if (sConfig.reentrancyLock) {\n            revert Reentrant();\n        }\n        _;\n    }\n\n    /**\n     * @inheritdoc ICoordinatorBase\n     */\n    function setConfig(uint32 maxGasLimit, uint32 gasAfterPaymentCalculation) external onlyOwner {\n        sConfig = Config({\n            maxGasLimit: maxGasLimit,\n            gasAfterPaymentCalculation: gasAfterPaymentCalculation,\n            reentrancyLock: false\n        });\n        emit ConfigSet(maxGasLimit, gasAfterPaymentCalculation);\n    }\n\n    function getConfig()\n        external\n        view\n        returns (uint32 maxGasLimit, uint32 gasAfterPaymentCalculation)\n    {\n        return (sConfig.maxGasLimit, sConfig.gasAfterPaymentCalculation);\n    }\n\n    /**\n     * @inheritdoc ICoordinatorBase\n     */\n    function getCommitment(uint256 requestId) external view returns (bytes32) {\n        return sRequestIdToCommitment[requestId];\n    }\n\n    /**\n     * @inheritdoc ICoordinatorBase\n     */\n    function cancelRequest(uint256 requestId) external {\n        if (!isValidRequestId(requestId)) {\n            revert NoCorrespondingRequest();\n        }\n\n        if (sRequestOwner[requestId] != msg.sender) {\n            revert NotRequestOwner();\n        }\n\n        delete sRequestIdToCommitment[requestId];\n        delete sRequestOwner[requestId];\n\n        emit RequestCanceled(requestId);\n    }\n\n    function calculateGasCost(uint256 startGas) internal view returns (uint256) {\n        return tx.gasprice * (sConfig.gasAfterPaymentCalculation + startGas - gasleft());\n    }\n\n    /**\n     * @dev calls target address with exactly gasAmount gas and data as calldata\n     * or reverts if at least gasAmount gas is not available.\n     */\n    function callWithExactGas(\n        uint256 gasAmount,\n        address target,\n        bytes memory data\n    ) internal returns (bool success) {\n        (success, ) = target.call{gas: gasAmount}(data);\n        return success;\n    }\n\n    function isValidRequestId(uint256 requestId) internal view returns (bool) {\n        if (sRequestIdToCommitment[requestId] != 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "src/interfaces/IADCSCoordinator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"./IADCSCoordinatorBase.sol\";\nimport \"./ICoordinatorBase.sol\";\n\ninterface IADCSCoordinator is IADCSCoordinatorBase, ICoordinatorBase {}\n"
    },
    "src/interfaces/IADCSCoordinatorBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"../libraries/ADCS.sol\";\n\ninterface IADCSCoordinatorBase {\n    // RequestCommitment holds information sent from off-chain oracle\n    // describing details of request.\n    struct RequestCommitment {\n        uint64 blockNum;\n        uint32 callbackGasLimit;\n        address sender;\n        bytes32 jobId;\n    }\n\n    struct StringAndBool {\n        string name;\n        bool response;\n    }\n\n    function requestData(\n        uint32 callbackGasLimit,\n        ADCS.Request memory req\n    ) external returns (uint256);\n\n    function fulfillDataRequestUint256(\n        uint256 requestId,\n        uint256 response,\n        RequestCommitment memory rc\n    ) external;\n\n    function fulfillDataRequestBool(\n        uint256 requestId,\n        bool response,\n        RequestCommitment memory rc\n    ) external;\n\n    function fulfillDataRequestBytes32(\n        uint256 requestId,\n        bytes32 response,\n        RequestCommitment memory rc\n    ) external;\n\n    function fulfillDataRequestBytes(\n        uint256 requestId,\n        bytes memory response,\n        RequestCommitment memory rc\n    ) external;\n\n    function fulfillDataRequestStringAndBool(\n        uint256 requestId,\n        StringAndBool memory response,\n        RequestCommitment memory rc\n    ) external;\n}\n"
    },
    "src/interfaces/IAlchemySmartAccount.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IAlchemySmartAccount {\n    function execute(address target, bytes calldata callData) external;\n    // Add other functions you need to interact with\n}\n"
    },
    "src/interfaces/ICoordinatorBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface ICoordinatorBase {\n    /**\n     * @notice Sets the configuration of the VRF coordinator\n     * @param maxGasLimit global max for request gas limit\n     * @param gasAfterPaymentCalculation gas used in doing accounting\n     * after completing the gas measurement\n     */\n    function setConfig(uint32 maxGasLimit, uint32 gasAfterPaymentCalculation) external;\n\n    function pendingRequestExists(address consumer, uint64 nonce) external view returns (bool);\n\n    /**\n     * @notice Get request commitment.\n     * @param requestId id of request\n     * @return commmitment value that can be used to determine whether\n     * a request is fulfilled or not. If `requestId` is valid and\n     * commitment equals to bytes32(0), the request was fulfilled.\n     */\n    function getCommitment(uint256 requestId) external view returns (bytes32);\n\n    /**\n     * @notice Canceling oracle request\n     * @param requestId - ID of the Oracle Request\n     */\n    function cancelRequest(uint256 requestId) external;\n}\n"
    },
    "src/interfaces/ITypeAndVersion.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/TypeAndVersionInterface.sol\n\nabstract contract ITypeAndVersion {\n    function typeAndVersion() external pure virtual returns (string memory);\n}\n"
    },
    "src/libraries/ADCS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n// https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/Chainlink.sol\n\nimport {Buffer} from \"./Buffer.sol\";\nimport {CBOR} from \"./CBOR.sol\";\n\nlibrary ADCS {\n    uint256 internal constant defaultBufferSize = 256;\n\n    using CBOR for Buffer.buffer;\n\n    // structure for storing requests done off-chain\n    struct Request {\n        bytes32 id;\n        address callbackAddr;\n        bytes4 callbackFunc;\n        uint256 nonce;\n        Buffer.buffer buf;\n    }\n\n    /**\n     * @notice Initializes a request\n     * @dev Sets ID, callback address, and callback function\n     * @param self The uninitialized request\n     * @param jobId The Job Specification ID\n     * @param callbackAddr The callback address\n     * @param callbackFunc The callback function signature\n     * @return The initialized request\n     */\n    function initialize(\n        Request memory self,\n        bytes32 jobId,\n        address callbackAddr,\n        bytes4 callbackFunc\n    ) internal pure returns (ADCS.Request memory) {\n        Buffer.init(self.buf, defaultBufferSize);\n        self.id = jobId;\n        self.callbackAddr = callbackAddr;\n        self.callbackFunc = callbackFunc;\n        return self;\n    }\n\n    /**\n     * @notice sets the data for buffer\n     * @param _request the initialized request\n     * @param _data the CBOR data\n     */\n    function setBuffer(Request memory _request, bytes memory _data) internal pure {\n        Buffer.init(_request.buf, _data.length);\n        Buffer.append(_request.buf, _data);\n    }\n\n    /**\n     * @notice Adds a string value to the request in a key - value pair format\n     * @param self - the initalized request\n     * @param key - the name of the key\n     * @param value - the string value to add\n     */\n    function add(Request memory self, string memory key, string memory value) internal pure {\n        self.buf.encodeString(key);\n        self.buf.encodeString(value);\n    }\n\n    /**\n     * @notice Adds a byte value to the request in a key - value pair format\n     * @param _request - the initalized request\n     * @param _key - the name of the key\n     * @param _value - the bytes value to add\n     */\n    function addBytes(\n        Request memory _request,\n        string memory _key,\n        bytes memory _value\n    ) internal pure {\n        _request.buf.encodeString(_key);\n        _request.buf.encodeBytes(_value);\n    }\n\n    /**\n     * @notice Adds a Int256 value to the request in a key - value pair format\n     * @param _request - the initalized request\n     * @param _key - the name of the key\n     * @param _value - the int256 value to add\n     */\n    function addInt(Request memory _request, string memory _key, int256 _value) internal pure {\n        _request.buf.encodeString(_key);\n        _request.buf.encodeInt(_value);\n    }\n\n    /**\n     * @notice Adds a UInt256 value to the request in a key - value pair format\n     * @param _request - the initalized request\n     * @param _key - the name of the key\n     * @param _value - the uint256 value to add\n     */\n    function addUInt(Request memory _request, string memory _key, uint256 _value) internal pure {\n        _request.buf.encodeString(_key);\n        _request.buf.encodeUInt(_value);\n    }\n\n    /**\n     * @notice Adds an array of string value to the request in a key - value pair format\n     * @param _request - the initalized request\n     * @param _key - the name of the key\n     * @param _values - the array of string value to add\n     */\n    function addStringArray(\n        Request memory _request,\n        string memory _key,\n        string[] memory _values\n    ) internal pure {\n        _request.buf.encodeString(_key);\n        _request.buf.startArray();\n        for (uint256 i; i < _values.length; i++) {\n            _request.buf.encodeString(_values[i]);\n        }\n        _request.buf.endSequence();\n    }\n}\n"
    },
    "src/libraries/Buffer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev A library for working with mutable byte buffers in Solidity.\n *\n * Byte buffers are mutable and expandable, and provide a variety of primitives\n * for writing to them. At any time you can fetch a bytes object containing the\n * current contents of the buffer. The bytes object should not be stored between\n * operations, as it may change due to resizing of the buffer.\n */\nlibrary Buffer {\n    /**\n     * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n     *      a capacity. The capacity may be longer than the current value, in\n     *      which case it can be extended without the need to allocate more memory.\n     */\n    struct buffer {\n        bytes buf;\n        uint256 capacity;\n    }\n\n    /**\n     * @dev Initializes a buffer with an initial capacity.\n     * @param buf The buffer to initialize.\n     * @param capacity The number of bytes of space to allocate the buffer.\n     * @return The buffer, for chaining.\n     */\n    function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            mstore(0x40, add(32, add(ptr, capacity)))\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Initializes a new buffer from an existing bytes object.\n     *      Changes to the buffer may mutate the original value.\n     * @param b The bytes object to initialize the buffer with.\n     * @return A new buffer.\n     */\n    function fromBytes(bytes memory b) internal pure returns (buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint256 capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    function max(uint256 a, uint256 b) private pure returns (uint256) {\n        if (a > b) {\n            return a;\n        }\n        return b;\n    }\n\n    /**\n     * @dev Sets buffer length to 0.\n     * @param buf The buffer to truncate.\n     * @return The original buffer, for chaining..\n     */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The start offset to write to.\n     * @param data The data to append.\n     * @param len The number of bytes to copy.\n     * @return The original buffer, for chaining.\n     */\n    function write(\n        buffer memory buf,\n        uint256 off,\n        bytes memory data,\n        uint256 len\n    ) internal pure returns (buffer memory) {\n        require(len <= data.length);\n\n        if (off + len > buf.capacity) {\n            resize(buf, max(buf.capacity, len + off) * 2);\n        }\n\n        uint256 dest;\n        uint256 src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(add(len, off), buflen) {\n                mstore(bufptr, add(len, off))\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint256 mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n     * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @param len The number of bytes to copy.\n     * @return The original buffer, for chaining.\n     */\n    function append(\n        buffer memory buf,\n        bytes memory data,\n        uint256 len\n    ) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, len);\n    }\n\n    /**\n     * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, data.length);\n    }\n\n    /**\n     * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n     *      capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The offset to write the byte at.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function writeUint8(\n        buffer memory buf,\n        uint256 off,\n        uint8 data\n    ) internal pure returns (buffer memory) {\n        if (off >= buf.capacity) {\n            resize(buf, buf.capacity * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if eq(off, buflen) {\n                mstore(bufptr, add(buflen, 1))\n            }\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n     *      capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\n        return writeUint8(buf, buf.buf.length, data);\n    }\n\n    /**\n     * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n     *      exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The offset to write at.\n     * @param data The data to append.\n     * @param len The number of bytes to write (left-aligned).\n     * @return The original buffer, for chaining.\n     */\n    function write(\n        buffer memory buf,\n        uint256 off,\n        bytes32 data,\n        uint256 len\n    ) private pure returns (buffer memory) {\n        if (len + off > buf.capacity) {\n            resize(buf, (len + off) * 2);\n        }\n\n        unchecked {\n            uint256 mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + off + len\n                let dest := add(add(bufptr, off), len)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(add(off, len), mload(bufptr)) {\n                    mstore(bufptr, add(off, len))\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n     *      capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The offset to write at.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function writeBytes20(\n        buffer memory buf,\n        uint256 off,\n        bytes20 data\n    ) internal pure returns (buffer memory) {\n        return write(buf, off, bytes32(data), 20);\n    }\n\n    /**\n     * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer, for chhaining.\n     */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, bytes32(data), 20);\n    }\n\n    /**\n     * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, 32);\n    }\n\n    /**\n     * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The offset to write at.\n     * @param data The data to append.\n     * @param len The number of bytes to write (right-aligned).\n     * @return The original buffer, for chaining.\n     */\n    function writeInt(\n        buffer memory buf,\n        uint256 off,\n        uint256 data,\n        uint256 len\n    ) private pure returns (buffer memory) {\n        if (len + off > buf.capacity) {\n            resize(buf, (len + off) * 2);\n        }\n\n        uint256 mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + off + sizeof(buffer length) + len\n            let dest := add(add(bufptr, off), len)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(add(off, len), mload(bufptr)) {\n                mstore(bufptr, add(off, len))\n            }\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     * exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer.\n     */\n    function appendInt(\n        buffer memory buf,\n        uint256 data,\n        uint256 len\n    ) internal pure returns (buffer memory) {\n        return writeInt(buf, buf.buf.length, data, len);\n    }\n}\n"
    },
    "src/libraries/CBOR.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n// https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vendor/CBORChainlink.sol\n\nimport {Buffer} from \"./Buffer.sol\";\n\n// Encoding library for Binary Object Representation\nlibrary CBOR {\n    using Buffer for Buffer.buffer;\n\n    // DECLARE TYPES FOR EASIER REFERENCE OF VARIABLE TYPE\n    uint8 private constant MAJOR_TYPE_INT = 0;\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\n    uint8 private constant MAJOR_TYPE_STRING = 3;\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\n    uint8 private constant MAJOR_TYPE_MAP = 5;\n    uint8 private constant MAJOR_TYPE_TAG = 6;\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n    uint8 private constant TAG_TYPE_BIGNUM = 2;\n    uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n    function encodeFixedNumeric(Buffer.buffer memory buf, uint8 major, uint64 value) private pure {\n        if (value <= 23) {\n            buf.appendUint8(uint8((major << 5) | value));\n        } else if (value <= 0xFF) {\n            buf.appendUint8(uint8((major << 5) | 24));\n            buf.appendInt(value, 1);\n        } else if (value <= 0xFFFF) {\n            buf.appendUint8(uint8((major << 5) | 25));\n            buf.appendInt(value, 2);\n        } else if (value <= 0xFFFFFFFF) {\n            buf.appendUint8(uint8((major << 5) | 26));\n            buf.appendInt(value, 4);\n        } else {\n            buf.appendUint8(uint8((major << 5) | 27));\n            buf.appendInt(value, 8);\n        }\n    }\n\n    function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private pure {\n        buf.appendUint8(uint8((major << 5) | 31));\n    }\n\n    function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {\n        if (value > 0xFFFFFFFFFFFFFFFF) {\n            encodeBigNum(buf, value);\n        } else {\n            encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n        }\n    }\n\n    function encodeInt(Buffer.buffer memory buf, int value) internal pure {\n        if (value < -0x10000000000000000) {\n            encodeSignedBigNum(buf, value);\n        } else if (value > 0xFFFFFFFFFFFFFFFF) {\n            encodeBigNum(buf, uint(value));\n        } else if (value >= 0) {\n            encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\n        } else {\n            encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\n        }\n    }\n\n    function encodeBytes(Buffer.buffer memory buf, bytes memory value) internal pure {\n        encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n        buf.append(value);\n    }\n\n    function encodeBigNum(Buffer.buffer memory buf, uint value) internal pure {\n        buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n        encodeBytes(buf, abi.encode(value));\n    }\n\n    function encodeSignedBigNum(Buffer.buffer memory buf, int input) internal pure {\n        buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\n        encodeBytes(buf, abi.encode(uint256(-1 - input)));\n    }\n\n    function encodeString(Buffer.buffer memory buf, string memory value) internal pure {\n        encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n        buf.append(bytes(value));\n    }\n\n    function startArray(Buffer.buffer memory buf) internal pure {\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n    }\n\n    function startMap(Buffer.buffer memory buf) internal pure {\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n    }\n\n    function endSequence(Buffer.buffer memory buf) internal pure {\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n    }\n}\n"
    },
    "src/mock/MockADCSConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../ADCSConsumerFulfill.sol\";\nimport \"../interfaces/IAlchemySmartAccount.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MockADCSConsumer is\n    ADCSConsumerFulfillUint256,\n    ADCSConsumerFulfillBool,\n    ADCSConsumerFulfillBytes32,\n    ADCSConsumerFulfillBytes,\n    ADCSConsumerFulfillStringAndBool,\n    Ownable\n{\n    using ADCS for ADCS.Request;\n    uint256 public lastUint256;\n    bool public lastBool;\n    bytes32 public lastBytes32;\n    bytes public lastBytes;\n\n    StringAndBool public lastestMemeCoin;\n\n    IAlchemySmartAccount public alchemySmartAccount;\n    ISwapRouter public uniswapRouter;\n\n    event DataRequestedUint256(uint256 indexed requestId);\n    event DataRequestedBool(uint256 indexed requestId);\n    event DataRequestedBytes32(uint256 indexed requestId);\n    event DataRequestedBytes(uint256 indexed requestId);\n    event DataRequestedStringAndBool(uint256 indexed requestId);\n    event TradeExecuted(address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOut);\n\n    constructor(\n        address _coordinator,\n        address _alchemySmartAccount,\n        address _uniswapRouter\n    ) ADCSConsumerBase(_coordinator) Ownable(_msgSender()) {\n        alchemySmartAccount = IAlchemySmartAccount(_alchemySmartAccount);\n        uniswapRouter = ISwapRouter(_uniswapRouter);\n    }\n\n    function requestUint256Data(\n        uint32 _callbackGasLimit,\n        bytes32 _jobId,\n        string memory _from,\n        string memory _to\n    ) external returns (uint256 requestId) {\n        bytes32 typeId = keccak256(abi.encodePacked(\"uint256\"));\n        ADCS.Request memory req = buildRequest(_jobId, typeId);\n        req.add(\"from\", _from);\n        req.add(\"to\", _to);\n        requestId = COORDINATOR.requestData(_callbackGasLimit, req);\n        emit DataRequestedUint256(requestId);\n    }\n\n    function requestBoolData(\n        uint32 _callbackGasLimit,\n        bytes32 _jobId,\n        string memory _from\n    ) external returns (uint256 requestId) {\n        bytes32 typeId = keccak256(abi.encodePacked(\"bool\"));\n        ADCS.Request memory req = buildRequest(_jobId, typeId);\n        req.add(\"from\", _from);\n        requestId = COORDINATOR.requestData(_callbackGasLimit, req);\n        emit DataRequestedBool(requestId);\n    }\n\n    function requestBytes32Data(\n        uint32 _callbackGasLimit,\n        bytes32 _jobId,\n        string memory _from\n    ) external returns (uint256 requestId) {\n        ADCS.Request memory req = buildRequest(_jobId, keccak256(abi.encodePacked(\"bytes32\")));\n        req.add(\"from\", _from);\n        requestId = COORDINATOR.requestData(_callbackGasLimit, req);\n        emit DataRequestedBytes32(requestId);\n    }\n\n    function requestMemeData(\n        uint32 _callbackGasLimit,\n        bytes32 _jobId\n    ) external returns (uint256 requestId) {\n        ADCS.Request memory req = buildRequest(\n            _jobId,\n            keccak256(abi.encodePacked(\"stringAndbool\"))\n        );\n        requestId = COORDINATOR.requestData(_callbackGasLimit, req);\n        emit DataRequestedBytes(requestId);\n    }\n\n    function requestBytesData(\n        uint32 _callbackGasLimit,\n        bytes32 _jobId,\n        string memory _from\n    ) external returns (uint256 requestId) {\n        ADCS.Request memory req = buildRequest(_jobId, keccak256(abi.encodePacked(\"bytes\")));\n        req.add(\"from\", _from);\n        requestId = COORDINATOR.requestData(_callbackGasLimit, req);\n        emit DataRequestedBytes(requestId);\n    }\n\n    function fulfillDataRequest(uint256, uint256 response) internal virtual override {\n        lastUint256 = response;\n    }\n\n    function fulfillDataRequest(uint256, bool response) internal virtual override {\n        lastBool = response;\n    }\n\n    function fulfillDataRequest(uint256, bytes32 response) internal virtual override {\n        lastBytes32 = response;\n    }\n\n    function fulfillDataRequest(uint256, bytes memory response) internal virtual override {\n        lastBytes = response;\n    }\n\n    function fulfillDataRequest(uint256, StringAndBool memory response) internal virtual override {\n        lastestMemeCoin = response;\n\n        // Example: Automatically execute a trade based on the received meme coin data\n        if (response.response) {\n            // Assuming boolValue indicates whether to buy or sell\n            // This is a simplified example. In a real-world scenario, you'd need more complex logic\n            // and proper error handling.\n            address wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // Mainnet WETH address\n            address memeTokenAddress = 0x1234567890123456789012345678901234567890; // Replace with actual meme token address\n            uint256 amountIn = 0.1 ether; // Example amount\n\n            executeTradeThroughSmartAccount(\n                wethAddress,\n                memeTokenAddress,\n                amountIn,\n                0, // Set a proper minimum amount out in a real scenario\n                3000 // 0.3% fee tier\n            );\n        }\n    }\n\n    function executeTradeThroughSmartAccount(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        uint24 fee\n    ) public onlyOwner {\n        bytes memory swapCalldata = abi.encodeWithSelector(\n            ISwapRouter.exactInputSingle.selector,\n            ISwapRouter.ExactInputSingleParams({\n                tokenIn: tokenIn,\n                tokenOut: tokenOut,\n                fee: fee,\n                recipient: address(alchemySmartAccount),\n                deadline: block.timestamp + 15 minutes,\n                amountIn: amountIn,\n                amountOutMinimum: amountOutMinimum,\n                sqrtPriceLimitX96: 0\n            })\n        );\n\n        alchemySmartAccount.execute(address(uniswapRouter), swapCalldata);\n\n        emit TradeExecuted(tokenIn, tokenOut, amountIn, amountOutMinimum);\n    }\n\n    function executeTradeOnUniswap(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        uint24 fee\n    ) external returns (uint256 amountOut) {\n        require(\n            msg.sender == address(alchemySmartAccount),\n            \"Only Alchemy Smart Account can execute trades\"\n        );\n\n        // Approve Uniswap router to spend tokens\n        IERC20(tokenIn).approve(address(uniswapRouter), amountIn);\n\n        // Prepare the swap parameters\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            fee: fee,\n            recipient: address(this),\n            deadline: block.timestamp + 15 minutes,\n            amountIn: amountIn,\n            amountOutMinimum: amountOutMinimum,\n            sqrtPriceLimitX96: 0\n        });\n\n        // Execute the swap\n        amountOut = uniswapRouter.exactInputSingle(params);\n\n        emit TradeExecuted(tokenIn, tokenOut, amountIn, amountOut);\n\n        return amountOut;\n    }\n\n    function setAlchemySmartAccount(address _alchemySmartAccount) external onlyOwner {\n        alchemySmartAccount = IAlchemySmartAccount(_alchemySmartAccount);\n    }\n\n    function setUniswapRouter(address _uniswapRouter) external onlyOwner {\n        uniswapRouter = ISwapRouter(_uniswapRouter);\n    }\n\n    function createApprovalCalldata(\n        address token,\n        uint256 amount\n    ) public view returns (bytes memory) {\n        return abi.encodeWithSelector(IERC20.approve.selector, address(uniswapRouter), amount);\n    }\n\n    function approveUniswapRouter(address token, uint256 amount) public onlyOwner {\n        bytes memory approvalCalldata = createApprovalCalldata(token, amount);\n        alchemySmartAccount.execute(token, approvalCalldata);\n    }\n\n    function approveAndTrade(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        uint24 fee\n    ) external onlyOwner {\n        // First, approve the Uniswap router to spend tokens\n        approveUniswapRouter(tokenIn, amountIn);\n\n        // Then, execute the trade\n        executeTradeThroughSmartAccount(tokenIn, tokenOut, amountIn, amountOutMinimum, fee);\n    }\n}\n"
    },
    "src/mock/MockADCSConsumerArray.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../ADCSConsumerFulfill.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Define a struct to hold the array data\nstruct CoinData {\n    string symbol;\n    bool signal;\n}\n\ncontract MockADCSConsumerArray is ADCSConsumerFulfillBytes, Ownable {\n    using ADCS for ADCS.Request;\n\n    // Store the last received response\n    bytes public lastResponse;\n    uint256 public lastRequestId;\n    CoinData public lastDecodedData;\n\n    event DataRequested(uint256 indexed requestId);\n    event DataFulfilled(uint256 indexed requestId, string symbol, bool signal);\n\n    constructor(address coordinator) ADCSConsumerBase(coordinator) Ownable(msg.sender) {}\n\n    // Function to request array data\n    function requestArrayData(\n        bytes32 jobId,\n        uint32 callbackGasLimit,\n        string memory _from\n    ) external onlyOwner returns (uint256 requestId) {\n        bytes32 typeId = keccak256(abi.encodePacked(\"bytes\"));\n        ADCS.Request memory req = buildRequest(jobId, typeId);\n        req.add(\"from\", _from);\n        requestId = COORDINATOR.requestData(callbackGasLimit, req);\n        emit DataRequested(requestId);\n        return requestId;\n    }\n\n    // Implementation of the fulfill function for bytes\n    function fulfillDataRequest(uint256 requestId, bytes memory response) internal override {\n        lastRequestId = requestId;\n        lastResponse = response;\n\n        // Decode the response into CoinData struct\n        (string memory symbol, bool signal) = abi.decode(response, (string, bool));\n        lastDecodedData = CoinData(symbol, signal);\n\n        emit DataFulfilled(requestId, symbol, signal);\n    }\n\n    // Helper function to encode CoinData\n    function encodeCoinData(\n        string memory symbol,\n        bool signal\n    ) external pure returns (bytes memory) {\n        return abi.encode(symbol, signal);\n    }\n\n    // Helper function to decode CoinData\n    function decodeCoinData(\n        bytes memory data\n    ) external pure returns (string memory symbol, bool signal) {\n        return abi.decode(data, (string, bool));\n    }\n\n    // Helper function to get the last decoded data\n    function getLastDecodedData() external view returns (string memory symbol, bool signal) {\n        return (lastDecodedData.symbol, lastDecodedData.signal);\n    }\n}\n"
    },
    "src/mock/MockADCSConsumerBytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../ADCSConsumerFulfill.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MockADCSConsumerBytes is ADCSConsumerFulfillBytes, Ownable {\n    using ADCS for ADCS.Request;\n\n    // Store the last received response for testing\n    bytes public lastResponse;\n    uint256 public lastRequestId;\n\n    event DataRequested(uint256 indexed requestId);\n    event DataFulfilled(uint256 indexed requestId, bytes response);\n\n    constructor(address coordinator) ADCSConsumerBase(coordinator) Ownable(msg.sender) {}\n\n    // Function to request bytes data\n    function requestBytesData(\n        bytes32 jobId,\n        uint32 callbackGasLimit,\n        string memory _from\n    ) external onlyOwner returns (uint256 requestId) {\n        bytes32 typeId = keccak256(abi.encodePacked(\"bytes32\"));\n        ADCS.Request memory req = buildRequest(jobId, typeId);\n        req.add(\"from\", _from);\n        requestId = COORDINATOR.requestData(callbackGasLimit, req);\n        emit DataRequested(requestId);\n        return requestId;\n    }\n\n    // Implementation of the fulfill function for bytes\n    function fulfillDataRequest(uint256 requestId, bytes memory response) internal override {\n        lastRequestId = requestId;\n        lastResponse = response;\n        emit DataFulfilled(requestId, response);\n    }\n\n    // Helper function to get the typeId for bytes\n    function getTypeId() external pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"bytes\"));\n    }\n}\n"
    },
    "src/mock/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MockERC20 is ERC20, Ownable {\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply\n    ) ERC20(name, symbol) Ownable(msg.sender) {\n        _mint(msg.sender, initialSupply);\n    }\n\n    function mint(address to, uint256 amount) external onlyOwner {\n        _mint(to, amount);\n    }\n}\n"
    },
    "src/mock/MockTradeMemeCoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../ADCSConsumerFulfill.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/IPeripheryPayments.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockTradeMemeCoin is ADCSConsumerFulfillStringAndBool, Ownable {\n    using ADCS for ADCS.Request;\n\n    // Store the last received response for testing\n    bytes public lastResponse;\n    uint256 public lastRequestId;\n    address public erc20Address;\n\n    // Store the amount for each request\n    mapping(uint256 => uint256) public requestIdToAmount;\n\n    struct MemeCoin {\n        string name;\n        address addr;\n    }\n\n    MemeCoin[] public memeCoins;\n\n    event DataRequested(uint256 indexed requestId);\n    event DataFulfilled(uint256 indexed requestId, bytes response);\n    event MemecoinNotFound(string tokenName);\n    event TradeSuccess(uint256 indexed requestId, uint256 amountIn, bool isBuy);\n\n    address public immutable WETH;\n    ISwapRouter public immutable swapRouter;\n\n    constructor(\n        address coordinator,\n        address _weth,\n        address _swapRouter\n    ) ADCSConsumerBase(coordinator) Ownable(msg.sender) {\n        WETH = _weth;\n        swapRouter = ISwapRouter(_swapRouter);\n    }\n\n    /**\n     * @notice Add a new memecoin to the list\n     * @param name The name of the memecoin\n     * @param addr The contract address of the memecoin\n     */\n    function addMemeCoin(string memory name, address addr) external onlyOwner {\n        memeCoins.push(MemeCoin({name: name, addr: addr}));\n    }\n\n    /**\n     * @notice Get the total number of memecoins in the list\n     * @return The length of the memecoins array\n     */\n    function getMemeCoinCount() external view returns (uint256) {\n        return memeCoins.length;\n    }\n\n    /**\n     * @notice Get a memecoin by index\n     * @param index The index in the memecoins array\n     * @return name The memecoin name\n     * @return addr The memecoin contract address\n     */\n    function getMemeCoin(uint256 index) external view returns (string memory name, address addr) {\n        require(index < memeCoins.length, \"Index out of bounds\");\n        MemeCoin memory coin = memeCoins[index];\n        return (coin.name, coin.addr);\n    }\n\n    function setErc20Address(address addr) external onlyOwner {\n        erc20Address = addr;\n    }\n\n    // Function to request bytes data\n    function requestTradeMemeCoin(\n        bytes32 jobId,\n        uint32 callbackGasLimit,\n        uint256 amount //meme coin amount\n    ) external onlyOwner returns (uint256 requestId) {\n        bytes32 typeId = keccak256(abi.encodePacked(\"stringAndbool\"));\n        ADCS.Request memory req = buildRequest(jobId, typeId);\n        requestId = COORDINATOR.requestData(callbackGasLimit, req);\n        requestIdToAmount[requestId] = amount;\n\n        emit DataRequested(requestId);\n        return requestId;\n    }\n\n    function executeUniswapV3Swap(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        uint24 fee\n    ) internal {\n        // Approve the router to spend tokens\n        IERC20(tokenIn).approve(address(swapRouter), amountIn);\n\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            fee: fee,\n            recipient: address(this),\n            deadline: block.timestamp + 15 minutes,\n            amountIn: amountIn,\n            amountOutMinimum: amountOutMinimum,\n            sqrtPriceLimitX96: 0\n        });\n\n        // Execute the swap\n        swapRouter.exactInputSingle(params);\n    }\n\n    function fulfillDataRequest(\n        uint256 requestId,\n        StringAndBool memory response\n    ) internal virtual override {\n        string memory tokenName = response.name;\n        bool result = response.response;\n        // Find memecoin address by name\n        address memeTokenAddress;\n        for (uint i = 0; i < memeCoins.length; i++) {\n            if (keccak256(bytes(memeCoins[i].name)) == keccak256(bytes(tokenName))) {\n                memeTokenAddress = memeCoins[i].addr;\n                break;\n            }\n        }\n        if (memeTokenAddress == address(0)) {\n            emit MemecoinNotFound(tokenName);\n            return;\n        }\n\n        // Get the amount stored for this request\n        uint256 amountIn = requestIdToAmount[requestId];\n\n        // Execute trade through Uniswap V3\n        if (result) {\n            // Buy memecoin with ERC20 token\n            executeUniswapV3Swap(\n                erc20Address,\n                memeTokenAddress,\n                amountIn,\n                0, // Set minimum amount out to 0 (should use proper slippage in production)\n                3000 // 0.3% fee tier\n            );\n            emit TradeSuccess(requestId, amountIn, true);\n        } else {\n            // Sell memecoin for ERC20 token\n            executeUniswapV3Swap(\n                memeTokenAddress,\n                erc20Address,\n                amountIn,\n                0, // Set minimum amount out to 0 (should use proper slippage in production)\n                3000 // 0.3% fee tier\n            );\n            emit TradeSuccess(requestId, amountIn, false);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}