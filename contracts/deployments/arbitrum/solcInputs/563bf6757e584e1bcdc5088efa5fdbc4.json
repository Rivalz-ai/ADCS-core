{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "src/ADCSConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./interfaces/IADCSCoordinator.sol\";\n\nabstract contract ADCSConsumerBase {\n    using ADCS for ADCS.Request;\n\n    struct StringAndBool {\n        string name;\n        bool response;\n    }\n    error OnlyCoordinatorCanFulfill(address have, address want);\n    mapping(bytes32 => bytes4) private sTypeIdToFunctionSelector;\n    IADCSCoordinator public immutable COORDINATOR;\n\n    /**\n     * @param _adcsResponseCoordinator address of ADCSCoordinator contract\n     */\n    constructor(address _adcsResponseCoordinator) {\n        COORDINATOR = IADCSCoordinator(_adcsResponseCoordinator);\n\n        sTypeIdToFunctionSelector[keccak256(abi.encodePacked(\"uint256\"))] = COORDINATOR\n            .fulfillDataRequestUint256\n            .selector;\n        sTypeIdToFunctionSelector[keccak256(abi.encodePacked(\"bool\"))] = COORDINATOR\n            .fulfillDataRequestBool\n            .selector;\n        sTypeIdToFunctionSelector[keccak256(abi.encodePacked(\"bytes32\"))] = COORDINATOR\n            .fulfillDataRequestBytes32\n            .selector;\n        sTypeIdToFunctionSelector[keccak256(abi.encodePacked(\"bytes\"))] = COORDINATOR\n            .fulfillDataRequestBytes\n            .selector;\n\n        sTypeIdToFunctionSelector[keccak256(abi.encodePacked(\"stringAndbool\"))] = COORDINATOR\n            .fulfillDataRequestStringAndBool\n            .selector;\n    }\n\n    /**\n     * @notice Build a request using the Orakl library\n     * @param jobId the job specification ID that the request is created for\n     * @param typeId the reponse type ID that the request is created for\n     * @return req request in memory\n     */\n    function buildRequest(\n        bytes32 jobId,\n        bytes32 typeId\n    ) internal view returns (ADCS.Request memory req) {\n        return req.initialize(jobId, address(COORDINATOR), sTypeIdToFunctionSelector[typeId]);\n    }\n\n    modifier verifyRawFulfillment() {\n        address coordinatorAddress = address(COORDINATOR);\n        if (msg.sender != coordinatorAddress) {\n            revert OnlyCoordinatorCanFulfill(msg.sender, coordinatorAddress);\n        }\n        _;\n    }\n}\n"
    },
    "src/ADCSConsumerFulfill.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./ADCSConsumerBase.sol\";\n\nabstract contract ADCSConsumerFulfillUint256 is ADCSConsumerBase {\n    function fulfillDataRequest(uint256 requestId, uint256 response) internal virtual;\n\n    function rawFulfillDataRequest(\n        uint256 requestId,\n        uint256 response\n    ) external verifyRawFulfillment {\n        fulfillDataRequest(requestId, response);\n    }\n}\n\nabstract contract ADCSConsumerFulfillBool is ADCSConsumerBase {\n    function fulfillDataRequest(uint256 requestId, bool response) internal virtual;\n\n    function rawFulfillDataRequest(uint256 requestId, bool response) external verifyRawFulfillment {\n        fulfillDataRequest(requestId, response);\n    }\n}\n\nabstract contract ADCSConsumerFulfillBytes32 is ADCSConsumerBase {\n    function fulfillDataRequest(uint256 requestId, bytes32 response) internal virtual;\n\n    function rawFulfillDataRequest(\n        uint256 requestId,\n        bytes32 response\n    ) external verifyRawFulfillment {\n        fulfillDataRequest(requestId, response);\n    }\n}\n\nabstract contract ADCSConsumerFulfillBytes is ADCSConsumerBase {\n    function fulfillDataRequest(uint256 requestId, bytes memory response) internal virtual;\n\n    function rawFulfillDataRequest(\n        uint256 requestId,\n        bytes memory response\n    ) external verifyRawFulfillment {\n        fulfillDataRequest(requestId, response);\n    }\n}\n\nabstract contract ADCSConsumerFulfillStringAndBool is ADCSConsumerBase {\n    function fulfillDataRequest(uint256 requestId, StringAndBool memory response) internal virtual;\n\n    function rawFulfillDataRequest(\n        uint256 requestId,\n        StringAndBool memory response\n    ) external verifyRawFulfillment {\n        fulfillDataRequest(requestId, response);\n    }\n}\n"
    },
    "src/ADCSCoordinator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"./interfaces/ITypeAndVersion.sol\";\nimport \"./interfaces/IADCSCoordinatorBase.sol\";\nimport \"./ADCSConsumerFulfill.sol\";\nimport \"./CoordinatorBase.sol\";\nimport \"./libraries/ADCS.sol\";\n\ncontract ADCSCoordinator is CoordinatorBase, IADCSCoordinatorBase, ITypeAndVersion {\n    uint8 public constant MAX_ORACLES = 255;\n\n    using ADCS for ADCS.Request;\n\n    struct Submission {\n        address[] oracles; // oracles that submitted response\n        mapping(address => bool) submitted;\n    }\n\n    /* requestId */\n    /* submission details */\n    mapping(uint256 => Submission) sSubmission;\n\n    /* oracle */\n    /* registration status */\n    mapping(address => bool) private sIsOracleRegistered;\n\n    mapping(address => uint64) private sConsumerToNonce;\n\n    error TooManyOracles();\n    error UnregisteredOracleFulfillment(address oracle);\n    error InvalidJobId();\n    error InvalidNumSubmission();\n    error OracleAlreadySubmitted();\n    error IncompatibleJobId();\n\n    event OracleRegistered(address oracle);\n    event OracleDeregistered(address oracle);\n    event PrepaymentSet(address prepayment);\n    event DataRequested(\n        uint256 indexed requestId,\n        uint32 callbackGasLimit,\n        address indexed sender,\n        bytes32 jobId,\n        uint256 blockNumber,\n        bytes data\n    );\n    event DataRequestFulfilledUint256(uint256 indexed requestId, uint256 response, bool success);\n    event DataRequestFulfilledBool(uint256 indexed requestId, bool response, bool success);\n    event DataRequestFulfilledBytes32(uint256 indexed requestId, bytes32 response, bool success);\n    event DataRequestFulfilledBytes(uint256 indexed requestId, bytes response, bool success);\n    event DataRequestFulfilledStringAndBool(\n        uint256 indexed requestId,\n        StringAndBool response,\n        bool success\n    );\n\n    event DataRequestFulfilled(uint256 indexed requestId, bytes response, bool success);\n\n    event DataSubmitted(address oracle, uint256 requestId);\n\n    constructor() {}\n\n    /**\n     * @notice Register an oracle\n     * @param oracle address of the oracle\n     */\n    function registerOracle(address oracle) external onlyOwner {\n        if (sOracles.length >= MAX_ORACLES) {\n            revert TooManyOracles();\n        }\n\n        if (sIsOracleRegistered[oracle]) {\n            revert OracleAlreadyRegistered(oracle);\n        }\n        sOracles.push(oracle);\n        sIsOracleRegistered[oracle] = true;\n        emit OracleRegistered(oracle);\n    }\n\n    /**\n     * @notice Deregister an oracle\n     * @param oracle address of the oracle\n     */\n    function deregisterOracle(address oracle) external onlyOwner {\n        if (!sIsOracleRegistered[oracle]) {\n            revert NoSuchOracle(oracle);\n        }\n        delete sIsOracleRegistered[oracle];\n\n        uint256 oraclesLength = sOracles.length;\n        for (uint256 i = 0; i < oraclesLength; ++i) {\n            if (sOracles[i] == oracle) {\n                address last = sOracles[oraclesLength - 1];\n                sOracles[i] = last;\n                sOracles.pop();\n                break;\n            }\n        }\n\n        emit OracleDeregistered(oracle);\n    }\n\n    /**\n     * @notice The type and version of this contract\n     * @return Type and version string\n     */\n    function typeAndVersion() external pure virtual override returns (string memory) {\n        return \"ADCSCoordinator v0.1\";\n    }\n\n    /**\n     * @notice Find out whether given oracle address was registered.\n     * @return true when oracle address registered, otherwise false\n     */\n    function isOracleRegistered(address oracle) external view returns (bool) {\n        return sIsOracleRegistered[oracle];\n    }\n\n    function computeRequestId(address sender, uint64 nonce) private pure returns (uint256) {\n        return uint256(keccak256(abi.encode(sender, nonce)));\n    }\n\n    function pendingRequestExists(address consumer, uint64 nonce) public view returns (bool) {\n        uint256 oraclesLength = sOracles.length;\n        for (uint256 i = 0; i < oraclesLength; ++i) {\n            uint256 requestId = computeRequestId(consumer, nonce);\n            if (isValidRequestId(requestId)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function increaseNonce(address consumer) private returns (uint64) {\n        uint64 nonce = sConsumerToNonce[consumer] + 1;\n        sConsumerToNonce[consumer] = nonce;\n        return nonce;\n    }\n\n    function requestData(\n        uint32 callbackGasLimit,\n        ADCS.Request memory req\n    ) external returns (uint256) {\n        if (callbackGasLimit > sConfig.maxGasLimit) {\n            revert GasLimitTooBig(callbackGasLimit, sConfig.maxGasLimit);\n        }\n        uint64 nonce = increaseNonce(msg.sender);\n        uint256 requestId = computeRequestId(msg.sender, nonce);\n        uint256 blockNumber = block.number;\n        sRequestIdToCommitment[requestId] = computeCommitment(\n            requestId,\n            blockNumber,\n            callbackGasLimit,\n            msg.sender,\n            req.id\n        );\n\n        sRequestOwner[requestId] = msg.sender;\n\n        emit DataRequested(\n            requestId,\n            callbackGasLimit,\n            msg.sender,\n            req.id,\n            blockNumber,\n            req.buf.buf\n        );\n\n        return requestId;\n    }\n\n    function validateDataResponse(RequestCommitment memory rc, uint256 requestId) private view {\n        if (!sIsOracleRegistered[msg.sender]) {\n            revert UnregisteredOracleFulfillment(msg.sender);\n        }\n\n        if (sSubmission[requestId].submitted[msg.sender]) {\n            revert OracleAlreadySubmitted();\n        }\n\n        bytes32 commitment = sRequestIdToCommitment[requestId];\n        if (commitment == 0) {\n            revert NoCorrespondingRequest();\n        }\n\n        if (\n            commitment !=\n            computeCommitment(requestId, rc.blockNum, rc.callbackGasLimit, rc.sender, rc.jobId)\n        ) {\n            revert IncorrectCommitment();\n        }\n    }\n\n    function fulfill(bytes memory resp, RequestCommitment memory rc) private returns (bool) {\n        // Call with explicitly the amount of callback gas requested\n        // Important to not let them exhaust the gas budget and avoid oracle payment.\n        // Do not allow any non-view/non-pure coordinator functions to be called\n        // during the consumers callback code via reentrancyLock.\n        // Note that callWithExactGas will revert if we do not have sufficient gas\n        // to give the callee their requested amount.\n        sConfig.reentrancyLock = true;\n        bool success = callWithExactGas(rc.callbackGasLimit, rc.sender, resp);\n        //\n        sConfig.reentrancyLock = false;\n        return success;\n    }\n\n    function cleanupAfterFulfillment(uint256 requestId) private returns (address[] memory) {\n        address[] memory oracles = sSubmission[requestId].oracles;\n\n        for (uint8 i = 0; i < oracles.length; ++i) {\n            delete sSubmission[requestId].submitted[oracles[i]];\n        }\n\n        delete sSubmission[requestId];\n        delete sRequestIdToCommitment[requestId];\n        delete sRequestOwner[requestId];\n\n        return oracles;\n    }\n\n    function uint256ToInt256(uint256[] memory arr) private pure returns (int256[] memory) {\n        int256[] memory responses = new int256[](arr.length);\n        for (uint256 i = 0; i < arr.length; i++) {\n            responses[i] = int256(uint256(arr[i]));\n        }\n        return responses;\n    }\n\n    function computeCommitment(\n        uint256 requestId,\n        uint256 blockNumber,\n        uint32 callbackGasLimit,\n        address sender,\n        bytes32 jobId\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(requestId, blockNumber, callbackGasLimit, sender, jobId));\n    }\n\n    function fulfillDataRequestUint256(\n        uint256 requestId,\n        uint256 response,\n        RequestCommitment memory rc\n    ) external nonReentrant {\n        validateDataResponse(rc, requestId);\n        sSubmission[requestId].submitted[msg.sender] = true;\n\n        address[] storage oracles = sSubmission[requestId].oracles;\n        oracles.push(msg.sender);\n        bytes memory resp = abi.encodeWithSelector(\n            ADCSConsumerFulfillUint256.rawFulfillDataRequest.selector,\n            requestId,\n            response\n        );\n        bool success = fulfill(resp, rc);\n        cleanupAfterFulfillment(requestId);\n\n        emit DataRequestFulfilledUint256(requestId, response, success);\n    }\n\n    function fulfillDataRequestBool(\n        uint256 requestId,\n        bool response,\n        RequestCommitment memory rc\n    ) external override {\n        validateDataResponse(rc, requestId);\n        sSubmission[requestId].submitted[msg.sender] = true;\n\n        address[] storage oracles = sSubmission[requestId].oracles;\n        oracles.push(msg.sender);\n        bytes memory resp = abi.encodeWithSelector(\n            ADCSConsumerFulfillBool.rawFulfillDataRequest.selector,\n            requestId,\n            response\n        );\n        bool success = fulfill(resp, rc);\n        cleanupAfterFulfillment(requestId);\n\n        emit DataRequestFulfilledBool(requestId, response, success);\n    }\n\n    function fulfillDataRequestBytes32(\n        uint256 requestId,\n        bytes32 response,\n        RequestCommitment memory rc\n    ) external override {\n        validateDataResponse(rc, requestId);\n        sSubmission[requestId].submitted[msg.sender] = true;\n\n        address[] storage oracles = sSubmission[requestId].oracles;\n        oracles.push(msg.sender);\n        bytes memory resp = abi.encodeWithSelector(\n            ADCSConsumerFulfillBytes32.rawFulfillDataRequest.selector,\n            requestId,\n            response\n        );\n        bool success = fulfill(resp, rc);\n        cleanupAfterFulfillment(requestId);\n\n        emit DataRequestFulfilledBytes32(requestId, response, success);\n    }\n\n    function fulfillDataRequestBytes(\n        uint256 requestId,\n        bytes memory response,\n        RequestCommitment memory rc\n    ) external override {\n        validateDataResponse(rc, requestId);\n        sSubmission[requestId].submitted[msg.sender] = true;\n\n        address[] storage oracles = sSubmission[requestId].oracles;\n        oracles.push(msg.sender);\n        bytes memory resp = abi.encodeWithSelector(\n            ADCSConsumerFulfillBytes.rawFulfillDataRequest.selector,\n            requestId,\n            response\n        );\n        bool success = fulfill(resp, rc);\n        cleanupAfterFulfillment(requestId);\n\n        emit DataRequestFulfilledBytes(requestId, response, success);\n    }\n\n    function fulfillDataRequestStringAndBool(\n        uint256 requestId,\n        StringAndBool memory response,\n        RequestCommitment memory rc\n    ) external override {\n        validateDataResponse(rc, requestId);\n        sSubmission[requestId].submitted[msg.sender] = true;\n\n        address[] storage oracles = sSubmission[requestId].oracles;\n        oracles.push(msg.sender);\n        bytes memory resp = abi.encodeWithSelector(\n            ADCSConsumerFulfillStringAndBool.rawFulfillDataRequest.selector,\n            requestId,\n            response\n        );\n        bool success = fulfill(resp, rc);\n        cleanupAfterFulfillment(requestId);\n\n        emit DataRequestFulfilledStringAndBool(requestId, response, success);\n    }\n}\n"
    },
    "src/CoordinatorBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/ICoordinatorBase.sol\";\n\nabstract contract CoordinatorBase is Ownable, ICoordinatorBase {\n    // 5k is plenty for an EXTCODESIZE call (2600) + warm CALL (100)\n    // and some arithmetic operations.\n    uint256 private constant GAS_FOR_CALL_EXACT_CHECK = 5_000;\n\n    address[] public sOracles;\n\n    /* requestID */\n    /* commitment */\n    mapping(uint256 => bytes32) internal sRequestIdToCommitment;\n\n    /* requestID */\n    /* owner */\n    mapping(uint256 => address) internal sRequestOwner;\n\n    struct Config {\n        uint32 maxGasLimit;\n        bool reentrancyLock;\n        // Gas to cover oracle payment after we calculate the payment.\n        // We make it configurable in case those operations are repriced.\n        uint32 gasAfterPaymentCalculation;\n    }\n    Config internal sConfig;\n\n    error Reentrant();\n    error NoCorrespondingRequest();\n    error NotRequestOwner();\n    error OracleAlreadyRegistered(address oracle);\n    error NoSuchOracle(address oracle);\n    error RefundFailure();\n    error InvalidConsumer(uint64 accId, address consumer);\n    error IncorrectCommitment();\n    error GasLimitTooBig(uint32 have, uint32 want);\n    error InsufficientPayment(uint256 have, uint256 want);\n\n    event ConfigSet(uint32 maxGasLimit, uint32 gasAfterPaymentCalculation);\n    event RequestCanceled(uint256 indexed requestId);\n\n    constructor() Ownable(_msgSender()) {}\n\n    modifier nonReentrant() {\n        if (sConfig.reentrancyLock) {\n            revert Reentrant();\n        }\n        _;\n    }\n\n    /**\n     * @inheritdoc ICoordinatorBase\n     */\n    function setConfig(uint32 maxGasLimit, uint32 gasAfterPaymentCalculation) external onlyOwner {\n        sConfig = Config({\n            maxGasLimit: maxGasLimit,\n            gasAfterPaymentCalculation: gasAfterPaymentCalculation,\n            reentrancyLock: false\n        });\n        emit ConfigSet(maxGasLimit, gasAfterPaymentCalculation);\n    }\n\n    function getConfig()\n        external\n        view\n        returns (uint32 maxGasLimit, uint32 gasAfterPaymentCalculation)\n    {\n        return (sConfig.maxGasLimit, sConfig.gasAfterPaymentCalculation);\n    }\n\n    /**\n     * @inheritdoc ICoordinatorBase\n     */\n    function getCommitment(uint256 requestId) external view returns (bytes32) {\n        return sRequestIdToCommitment[requestId];\n    }\n\n    /**\n     * @inheritdoc ICoordinatorBase\n     */\n    function cancelRequest(uint256 requestId) external {\n        if (!isValidRequestId(requestId)) {\n            revert NoCorrespondingRequest();\n        }\n\n        if (sRequestOwner[requestId] != msg.sender) {\n            revert NotRequestOwner();\n        }\n\n        delete sRequestIdToCommitment[requestId];\n        delete sRequestOwner[requestId];\n\n        emit RequestCanceled(requestId);\n    }\n\n    function calculateGasCost(uint256 startGas) internal view returns (uint256) {\n        return tx.gasprice * (sConfig.gasAfterPaymentCalculation + startGas - gasleft());\n    }\n\n    /**\n     * @dev calls target address with exactly gasAmount gas and data as calldata\n     * or reverts if at least gasAmount gas is not available.\n     */\n    function callWithExactGas(\n        uint256 gasAmount,\n        address target,\n        bytes memory data\n    ) internal returns (bool success) {\n        (success, ) = target.call{gas: gasAmount}(data);\n        return success;\n    }\n\n    function isValidRequestId(uint256 requestId) internal view returns (bool) {\n        if (sRequestIdToCommitment[requestId] != 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "src/interfaces/IADCSCoordinator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"./IADCSCoordinatorBase.sol\";\nimport \"./ICoordinatorBase.sol\";\n\ninterface IADCSCoordinator is IADCSCoordinatorBase, ICoordinatorBase {}\n"
    },
    "src/interfaces/IADCSCoordinatorBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"../libraries/ADCS.sol\";\n\ninterface IADCSCoordinatorBase {\n    // RequestCommitment holds information sent from off-chain oracle\n    // describing details of request.\n    struct RequestCommitment {\n        uint64 blockNum;\n        uint32 callbackGasLimit;\n        address sender;\n        bytes32 jobId;\n    }\n\n    struct StringAndBool {\n        string name;\n        bool response;\n    }\n\n    function requestData(\n        uint32 callbackGasLimit,\n        ADCS.Request memory req\n    ) external returns (uint256);\n\n    function fulfillDataRequestUint256(\n        uint256 requestId,\n        uint256 response,\n        RequestCommitment memory rc\n    ) external;\n\n    function fulfillDataRequestBool(\n        uint256 requestId,\n        bool response,\n        RequestCommitment memory rc\n    ) external;\n\n    function fulfillDataRequestBytes32(\n        uint256 requestId,\n        bytes32 response,\n        RequestCommitment memory rc\n    ) external;\n\n    function fulfillDataRequestBytes(\n        uint256 requestId,\n        bytes memory response,\n        RequestCommitment memory rc\n    ) external;\n\n    function fulfillDataRequestStringAndBool(\n        uint256 requestId,\n        StringAndBool memory response,\n        RequestCommitment memory rc\n    ) external;\n}\n"
    },
    "src/interfaces/ICoordinatorBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface ICoordinatorBase {\n    /**\n     * @notice Sets the configuration of the VRF coordinator\n     * @param maxGasLimit global max for request gas limit\n     * @param gasAfterPaymentCalculation gas used in doing accounting\n     * after completing the gas measurement\n     */\n    function setConfig(uint32 maxGasLimit, uint32 gasAfterPaymentCalculation) external;\n\n    function pendingRequestExists(address consumer, uint64 nonce) external view returns (bool);\n\n    /**\n     * @notice Get request commitment.\n     * @param requestId id of request\n     * @return commmitment value that can be used to determine whether\n     * a request is fulfilled or not. If `requestId` is valid and\n     * commitment equals to bytes32(0), the request was fulfilled.\n     */\n    function getCommitment(uint256 requestId) external view returns (bytes32);\n\n    /**\n     * @notice Canceling oracle request\n     * @param requestId - ID of the Oracle Request\n     */\n    function cancelRequest(uint256 requestId) external;\n}\n"
    },
    "src/interfaces/ITypeAndVersion.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/TypeAndVersionInterface.sol\n\nabstract contract ITypeAndVersion {\n    function typeAndVersion() external pure virtual returns (string memory);\n}\n"
    },
    "src/libraries/ADCS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n// https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/Chainlink.sol\n\nimport {Buffer} from \"./Buffer.sol\";\nimport {CBOR} from \"./CBOR.sol\";\n\nlibrary ADCS {\n    uint256 internal constant defaultBufferSize = 256;\n\n    using CBOR for Buffer.buffer;\n\n    // structure for storing requests done off-chain\n    struct Request {\n        bytes32 id;\n        address callbackAddr;\n        bytes4 callbackFunc;\n        uint256 nonce;\n        Buffer.buffer buf;\n    }\n\n    /**\n     * @notice Initializes a request\n     * @dev Sets ID, callback address, and callback function\n     * @param self The uninitialized request\n     * @param jobId The Job Specification ID\n     * @param callbackAddr The callback address\n     * @param callbackFunc The callback function signature\n     * @return The initialized request\n     */\n    function initialize(\n        Request memory self,\n        bytes32 jobId,\n        address callbackAddr,\n        bytes4 callbackFunc\n    ) internal pure returns (ADCS.Request memory) {\n        Buffer.init(self.buf, defaultBufferSize);\n        self.id = jobId;\n        self.callbackAddr = callbackAddr;\n        self.callbackFunc = callbackFunc;\n        return self;\n    }\n\n    /**\n     * @notice sets the data for buffer\n     * @param _request the initialized request\n     * @param _data the CBOR data\n     */\n    function setBuffer(Request memory _request, bytes memory _data) internal pure {\n        Buffer.init(_request.buf, _data.length);\n        Buffer.append(_request.buf, _data);\n    }\n\n    /**\n     * @notice Adds a string value to the request in a key - value pair format\n     * @param self - the initalized request\n     * @param key - the name of the key\n     * @param value - the string value to add\n     */\n    function add(Request memory self, string memory key, string memory value) internal pure {\n        self.buf.encodeString(key);\n        self.buf.encodeString(value);\n    }\n\n    /**\n     * @notice Adds a byte value to the request in a key - value pair format\n     * @param _request - the initalized request\n     * @param _key - the name of the key\n     * @param _value - the bytes value to add\n     */\n    function addBytes(\n        Request memory _request,\n        string memory _key,\n        bytes memory _value\n    ) internal pure {\n        _request.buf.encodeString(_key);\n        _request.buf.encodeBytes(_value);\n    }\n\n    /**\n     * @notice Adds a Int256 value to the request in a key - value pair format\n     * @param _request - the initalized request\n     * @param _key - the name of the key\n     * @param _value - the int256 value to add\n     */\n    function addInt(Request memory _request, string memory _key, int256 _value) internal pure {\n        _request.buf.encodeString(_key);\n        _request.buf.encodeInt(_value);\n    }\n\n    /**\n     * @notice Adds a UInt256 value to the request in a key - value pair format\n     * @param _request - the initalized request\n     * @param _key - the name of the key\n     * @param _value - the uint256 value to add\n     */\n    function addUInt(Request memory _request, string memory _key, uint256 _value) internal pure {\n        _request.buf.encodeString(_key);\n        _request.buf.encodeUInt(_value);\n    }\n\n    /**\n     * @notice Adds an array of string value to the request in a key - value pair format\n     * @param _request - the initalized request\n     * @param _key - the name of the key\n     * @param _values - the array of string value to add\n     */\n    function addStringArray(\n        Request memory _request,\n        string memory _key,\n        string[] memory _values\n    ) internal pure {\n        _request.buf.encodeString(_key);\n        _request.buf.startArray();\n        for (uint256 i; i < _values.length; i++) {\n            _request.buf.encodeString(_values[i]);\n        }\n        _request.buf.endSequence();\n    }\n}\n"
    },
    "src/libraries/Buffer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev A library for working with mutable byte buffers in Solidity.\n *\n * Byte buffers are mutable and expandable, and provide a variety of primitives\n * for writing to them. At any time you can fetch a bytes object containing the\n * current contents of the buffer. The bytes object should not be stored between\n * operations, as it may change due to resizing of the buffer.\n */\nlibrary Buffer {\n    /**\n     * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n     *      a capacity. The capacity may be longer than the current value, in\n     *      which case it can be extended without the need to allocate more memory.\n     */\n    struct buffer {\n        bytes buf;\n        uint256 capacity;\n    }\n\n    /**\n     * @dev Initializes a buffer with an initial capacity.\n     * @param buf The buffer to initialize.\n     * @param capacity The number of bytes of space to allocate the buffer.\n     * @return The buffer, for chaining.\n     */\n    function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            mstore(0x40, add(32, add(ptr, capacity)))\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Initializes a new buffer from an existing bytes object.\n     *      Changes to the buffer may mutate the original value.\n     * @param b The bytes object to initialize the buffer with.\n     * @return A new buffer.\n     */\n    function fromBytes(bytes memory b) internal pure returns (buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint256 capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    function max(uint256 a, uint256 b) private pure returns (uint256) {\n        if (a > b) {\n            return a;\n        }\n        return b;\n    }\n\n    /**\n     * @dev Sets buffer length to 0.\n     * @param buf The buffer to truncate.\n     * @return The original buffer, for chaining..\n     */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The start offset to write to.\n     * @param data The data to append.\n     * @param len The number of bytes to copy.\n     * @return The original buffer, for chaining.\n     */\n    function write(\n        buffer memory buf,\n        uint256 off,\n        bytes memory data,\n        uint256 len\n    ) internal pure returns (buffer memory) {\n        require(len <= data.length);\n\n        if (off + len > buf.capacity) {\n            resize(buf, max(buf.capacity, len + off) * 2);\n        }\n\n        uint256 dest;\n        uint256 src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(add(len, off), buflen) {\n                mstore(bufptr, add(len, off))\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint256 mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n     * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @param len The number of bytes to copy.\n     * @return The original buffer, for chaining.\n     */\n    function append(\n        buffer memory buf,\n        bytes memory data,\n        uint256 len\n    ) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, len);\n    }\n\n    /**\n     * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, data.length);\n    }\n\n    /**\n     * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n     *      capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The offset to write the byte at.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function writeUint8(\n        buffer memory buf,\n        uint256 off,\n        uint8 data\n    ) internal pure returns (buffer memory) {\n        if (off >= buf.capacity) {\n            resize(buf, buf.capacity * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if eq(off, buflen) {\n                mstore(bufptr, add(buflen, 1))\n            }\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n     *      capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\n        return writeUint8(buf, buf.buf.length, data);\n    }\n\n    /**\n     * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n     *      exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The offset to write at.\n     * @param data The data to append.\n     * @param len The number of bytes to write (left-aligned).\n     * @return The original buffer, for chaining.\n     */\n    function write(\n        buffer memory buf,\n        uint256 off,\n        bytes32 data,\n        uint256 len\n    ) private pure returns (buffer memory) {\n        if (len + off > buf.capacity) {\n            resize(buf, (len + off) * 2);\n        }\n\n        unchecked {\n            uint256 mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + off + len\n                let dest := add(add(bufptr, off), len)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(add(off, len), mload(bufptr)) {\n                    mstore(bufptr, add(off, len))\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n     *      capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The offset to write at.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function writeBytes20(\n        buffer memory buf,\n        uint256 off,\n        bytes20 data\n    ) internal pure returns (buffer memory) {\n        return write(buf, off, bytes32(data), 20);\n    }\n\n    /**\n     * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer, for chhaining.\n     */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, bytes32(data), 20);\n    }\n\n    /**\n     * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, 32);\n    }\n\n    /**\n     * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The offset to write at.\n     * @param data The data to append.\n     * @param len The number of bytes to write (right-aligned).\n     * @return The original buffer, for chaining.\n     */\n    function writeInt(\n        buffer memory buf,\n        uint256 off,\n        uint256 data,\n        uint256 len\n    ) private pure returns (buffer memory) {\n        if (len + off > buf.capacity) {\n            resize(buf, (len + off) * 2);\n        }\n\n        uint256 mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + off + sizeof(buffer length) + len\n            let dest := add(add(bufptr, off), len)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(add(off, len), mload(bufptr)) {\n                mstore(bufptr, add(off, len))\n            }\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     * exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer.\n     */\n    function appendInt(\n        buffer memory buf,\n        uint256 data,\n        uint256 len\n    ) internal pure returns (buffer memory) {\n        return writeInt(buf, buf.buf.length, data, len);\n    }\n}\n"
    },
    "src/libraries/CBOR.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n// https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vendor/CBORChainlink.sol\n\nimport {Buffer} from \"./Buffer.sol\";\n\n// Encoding library for Binary Object Representation\nlibrary CBOR {\n    using Buffer for Buffer.buffer;\n\n    // DECLARE TYPES FOR EASIER REFERENCE OF VARIABLE TYPE\n    uint8 private constant MAJOR_TYPE_INT = 0;\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\n    uint8 private constant MAJOR_TYPE_STRING = 3;\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\n    uint8 private constant MAJOR_TYPE_MAP = 5;\n    uint8 private constant MAJOR_TYPE_TAG = 6;\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n    uint8 private constant TAG_TYPE_BIGNUM = 2;\n    uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n    function encodeFixedNumeric(Buffer.buffer memory buf, uint8 major, uint64 value) private pure {\n        if (value <= 23) {\n            buf.appendUint8(uint8((major << 5) | value));\n        } else if (value <= 0xFF) {\n            buf.appendUint8(uint8((major << 5) | 24));\n            buf.appendInt(value, 1);\n        } else if (value <= 0xFFFF) {\n            buf.appendUint8(uint8((major << 5) | 25));\n            buf.appendInt(value, 2);\n        } else if (value <= 0xFFFFFFFF) {\n            buf.appendUint8(uint8((major << 5) | 26));\n            buf.appendInt(value, 4);\n        } else {\n            buf.appendUint8(uint8((major << 5) | 27));\n            buf.appendInt(value, 8);\n        }\n    }\n\n    function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private pure {\n        buf.appendUint8(uint8((major << 5) | 31));\n    }\n\n    function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {\n        if (value > 0xFFFFFFFFFFFFFFFF) {\n            encodeBigNum(buf, value);\n        } else {\n            encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n        }\n    }\n\n    function encodeInt(Buffer.buffer memory buf, int value) internal pure {\n        if (value < -0x10000000000000000) {\n            encodeSignedBigNum(buf, value);\n        } else if (value > 0xFFFFFFFFFFFFFFFF) {\n            encodeBigNum(buf, uint(value));\n        } else if (value >= 0) {\n            encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\n        } else {\n            encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\n        }\n    }\n\n    function encodeBytes(Buffer.buffer memory buf, bytes memory value) internal pure {\n        encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n        buf.append(value);\n    }\n\n    function encodeBigNum(Buffer.buffer memory buf, uint value) internal pure {\n        buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n        encodeBytes(buf, abi.encode(value));\n    }\n\n    function encodeSignedBigNum(Buffer.buffer memory buf, int input) internal pure {\n        buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\n        encodeBytes(buf, abi.encode(uint256(-1 - input)));\n    }\n\n    function encodeString(Buffer.buffer memory buf, string memory value) internal pure {\n        encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n        buf.append(bytes(value));\n    }\n\n    function startArray(Buffer.buffer memory buf) internal pure {\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n    }\n\n    function startMap(Buffer.buffer memory buf) internal pure {\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n    }\n\n    function endSequence(Buffer.buffer memory buf) internal pure {\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}