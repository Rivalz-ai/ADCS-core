{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@uniswap/swap-router-contracts/contracts/interfaces/IV3SwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface IV3SwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// that may remain in the router after the swap.\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// that may remain in the router after the swap.\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/IPeripheryPayments.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\n/// @title Periphery Payments\n/// @notice Functions to ease deposits and withdrawals of ETH\ninterface IPeripheryPayments {\n    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.\n    /// @param amountMinimum The minimum amount of WETH9 to unwrap\n    /// @param recipient The address receiving ETH\n    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;\n\n    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\n    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\n    /// that use ether for the input amount\n    function refundETH() external payable;\n\n    /// @notice Transfers the full amount of a token held by this contract to recipient\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\n    /// @param token The contract address of the token which will be transferred to `recipient`\n    /// @param amountMinimum The minimum amount of token required for a transfer\n    /// @param recipient The destination address of the token\n    function sweepToken(\n        address token,\n        uint256 amountMinimum,\n        address recipient\n    ) external payable;\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "src/ADCSConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./interfaces/IADCSCoordinator.sol\";\n\nabstract contract ADCSConsumerBase {\n    using ADCS for ADCS.Request;\n\n    struct StringAndBool {\n        string name;\n        bool response;\n    }\n    error OnlyCoordinatorCanFulfill(address have, address want);\n    mapping(bytes32 => bytes4) private sTypeIdToFunctionSelector;\n    IADCSCoordinator public immutable COORDINATOR;\n\n    /**\n     * @param _adcsResponseCoordinator address of ADCSCoordinator contract\n     */\n    constructor(address _adcsResponseCoordinator) {\n        COORDINATOR = IADCSCoordinator(_adcsResponseCoordinator);\n\n        sTypeIdToFunctionSelector[keccak256(abi.encodePacked(\"uint256\"))] = COORDINATOR\n            .fulfillDataRequestUint256\n            .selector;\n        sTypeIdToFunctionSelector[keccak256(abi.encodePacked(\"bool\"))] = COORDINATOR\n            .fulfillDataRequestBool\n            .selector;\n        sTypeIdToFunctionSelector[keccak256(abi.encodePacked(\"bytes32\"))] = COORDINATOR\n            .fulfillDataRequestBytes32\n            .selector;\n        sTypeIdToFunctionSelector[keccak256(abi.encodePacked(\"bytes\"))] = COORDINATOR\n            .fulfillDataRequestBytes\n            .selector;\n\n        sTypeIdToFunctionSelector[keccak256(abi.encodePacked(\"stringAndbool\"))] = COORDINATOR\n            .fulfillDataRequestStringAndBool\n            .selector;\n    }\n\n    /**\n     * @notice Build a request using the Orakl library\n     * @param jobId the job specification ID that the request is created for\n     * @param typeId the reponse type ID that the request is created for\n     * @return req request in memory\n     */\n    function buildRequest(\n        bytes32 jobId,\n        bytes32 typeId\n    ) internal view returns (ADCS.Request memory req) {\n        return req.initialize(jobId, address(COORDINATOR), sTypeIdToFunctionSelector[typeId]);\n    }\n\n    modifier verifyRawFulfillment() {\n        address coordinatorAddress = address(COORDINATOR);\n        if (msg.sender != coordinatorAddress) {\n            revert OnlyCoordinatorCanFulfill(msg.sender, coordinatorAddress);\n        }\n        _;\n    }\n}\n"
    },
    "src/ADCSConsumerFulfill.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./ADCSConsumerBase.sol\";\n\nabstract contract ADCSConsumerFulfillUint256 is ADCSConsumerBase {\n    function fulfillDataRequest(uint256 requestId, uint256 response) internal virtual;\n\n    function rawFulfillDataRequest(\n        uint256 requestId,\n        uint256 response\n    ) external verifyRawFulfillment {\n        fulfillDataRequest(requestId, response);\n    }\n}\n\nabstract contract ADCSConsumerFulfillBool is ADCSConsumerBase {\n    function fulfillDataRequest(uint256 requestId, bool response) internal virtual;\n\n    function rawFulfillDataRequest(uint256 requestId, bool response) external verifyRawFulfillment {\n        fulfillDataRequest(requestId, response);\n    }\n}\n\nabstract contract ADCSConsumerFulfillBytes32 is ADCSConsumerBase {\n    function fulfillDataRequest(uint256 requestId, bytes32 response) internal virtual;\n\n    function rawFulfillDataRequest(\n        uint256 requestId,\n        bytes32 response\n    ) external verifyRawFulfillment {\n        fulfillDataRequest(requestId, response);\n    }\n}\n\nabstract contract ADCSConsumerFulfillBytes is ADCSConsumerBase {\n    function fulfillDataRequest(uint256 requestId, bytes memory response) internal virtual;\n\n    function rawFulfillDataRequest(\n        uint256 requestId,\n        bytes memory response\n    ) external verifyRawFulfillment {\n        fulfillDataRequest(requestId, response);\n    }\n}\n\nabstract contract ADCSConsumerFulfillStringAndBool is ADCSConsumerBase {\n    function fulfillDataRequest(uint256 requestId, StringAndBool memory response) internal virtual;\n\n    function rawFulfillDataRequest(\n        uint256 requestId,\n        StringAndBool memory response\n    ) external verifyRawFulfillment {\n        fulfillDataRequest(requestId, response);\n    }\n}\n"
    },
    "src/ADCSCoordinator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"./interfaces/ITypeAndVersion.sol\";\nimport \"./interfaces/IADCSCoordinatorBase.sol\";\nimport \"./ADCSConsumerFulfill.sol\";\nimport \"./CoordinatorBase.sol\";\nimport \"./libraries/ADCS.sol\";\n\ncontract ADCSCoordinator is CoordinatorBase, IADCSCoordinatorBase, ITypeAndVersion {\n    uint8 public constant MAX_ORACLES = 255;\n\n    using ADCS for ADCS.Request;\n\n    struct Submission {\n        address[] oracles; // oracles that submitted response\n        mapping(address => bool) submitted;\n    }\n\n    /* requestId */\n    /* submission details */\n    mapping(uint256 => Submission) sSubmission;\n\n    /* oracle */\n    /* registration status */\n    mapping(address => bool) private sIsOracleRegistered;\n\n    mapping(address => uint64) private sConsumerToNonce;\n\n    error TooManyOracles();\n    error UnregisteredOracleFulfillment(address oracle);\n    error InvalidJobId();\n    error InvalidNumSubmission();\n    error OracleAlreadySubmitted();\n    error IncompatibleJobId();\n\n    event OracleRegistered(address oracle);\n    event OracleDeregistered(address oracle);\n    event PrepaymentSet(address prepayment);\n    event DataRequested(\n        uint256 indexed requestId,\n        uint256 callbackGasLimit,\n        address indexed sender,\n        bytes32 jobId,\n        uint256 blockNumber,\n        bytes data\n    );\n    event DataRequestFulfilledUint256(uint256 indexed requestId, uint256 response, bool success);\n    event DataRequestFulfilledBool(uint256 indexed requestId, bool response, bool success);\n    event DataRequestFulfilledBytes32(uint256 indexed requestId, bytes32 response, bool success);\n    event DataRequestFulfilledBytes(uint256 indexed requestId, bytes response, bool success);\n    event DataRequestFulfilledStringAndBool(\n        uint256 indexed requestId,\n        StringAndBool response,\n        bool success\n    );\n\n    event DataRequestFulfilled(uint256 indexed requestId, bytes response, bool success);\n\n    event DataSubmitted(address oracle, uint256 requestId);\n\n    constructor() {}\n\n    /**\n     * @notice Register an oracle\n     * @param oracle address of the oracle\n     */\n    function registerOracle(address oracle) external onlyOwner {\n        if (sOracles.length >= MAX_ORACLES) {\n            revert TooManyOracles();\n        }\n\n        if (sIsOracleRegistered[oracle]) {\n            revert OracleAlreadyRegistered(oracle);\n        }\n        sOracles.push(oracle);\n        sIsOracleRegistered[oracle] = true;\n        emit OracleRegistered(oracle);\n    }\n\n    /**\n     * @notice Deregister an oracle\n     * @param oracle address of the oracle\n     */\n    function deregisterOracle(address oracle) external onlyOwner {\n        if (!sIsOracleRegistered[oracle]) {\n            revert NoSuchOracle(oracle);\n        }\n        delete sIsOracleRegistered[oracle];\n\n        uint256 oraclesLength = sOracles.length;\n        for (uint256 i = 0; i < oraclesLength; ++i) {\n            if (sOracles[i] == oracle) {\n                address last = sOracles[oraclesLength - 1];\n                sOracles[i] = last;\n                sOracles.pop();\n                break;\n            }\n        }\n\n        emit OracleDeregistered(oracle);\n    }\n\n    /**\n     * @notice The type and version of this contract\n     * @return Type and version string\n     */\n    function typeAndVersion() external pure virtual override returns (string memory) {\n        return \"ADCSCoordinator v0.1\";\n    }\n\n    /**\n     * @notice Find out whether given oracle address was registered.\n     * @return true when oracle address registered, otherwise false\n     */\n    function isOracleRegistered(address oracle) external view returns (bool) {\n        return sIsOracleRegistered[oracle];\n    }\n\n    function computeRequestId(address sender, uint64 nonce) private pure returns (uint256) {\n        return uint256(keccak256(abi.encode(sender, nonce)));\n    }\n\n    function pendingRequestExists(address consumer, uint64 nonce) public view returns (bool) {\n        uint256 oraclesLength = sOracles.length;\n        for (uint256 i = 0; i < oraclesLength; ++i) {\n            uint256 requestId = computeRequestId(consumer, nonce);\n            if (isValidRequestId(requestId)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function increaseNonce(address consumer) private returns (uint64) {\n        uint64 nonce = sConsumerToNonce[consumer] + 1;\n        sConsumerToNonce[consumer] = nonce;\n        return nonce;\n    }\n\n    function requestData(\n        uint256 callbackGasLimit,\n        ADCS.Request memory req\n    ) external returns (uint256) {\n        if (callbackGasLimit > sConfig.maxGasLimit) {\n            revert GasLimitTooBig(callbackGasLimit, sConfig.maxGasLimit);\n        }\n        uint64 nonce = increaseNonce(msg.sender);\n        uint256 requestId = computeRequestId(msg.sender, nonce);\n        uint256 blockNumber = block.number;\n        sRequestIdToCommitment[requestId] = computeCommitment(\n            requestId,\n            blockNumber,\n            callbackGasLimit,\n            msg.sender,\n            req.id\n        );\n\n        sRequestOwner[requestId] = msg.sender;\n\n        emit DataRequested(\n            requestId,\n            callbackGasLimit,\n            msg.sender,\n            req.id,\n            blockNumber,\n            req.buf.buf\n        );\n\n        return requestId;\n    }\n\n    function validateDataResponse(RequestCommitment memory rc, uint256 requestId) private view {\n        if (!sIsOracleRegistered[msg.sender]) {\n            revert UnregisteredOracleFulfillment(msg.sender);\n        }\n\n        if (sSubmission[requestId].submitted[msg.sender]) {\n            revert OracleAlreadySubmitted();\n        }\n\n        bytes32 commitment = sRequestIdToCommitment[requestId];\n        if (commitment == 0) {\n            revert NoCorrespondingRequest();\n        }\n\n        if (\n            commitment !=\n            computeCommitment(requestId, rc.blockNum, rc.callbackGasLimit, rc.sender, rc.jobId)\n        ) {\n            revert IncorrectCommitment();\n        }\n    }\n\n    function fulfill(bytes memory resp, RequestCommitment memory rc) private returns (bool) {\n        // Call with explicitly the amount of callback gas requested\n        // Important to not let them exhaust the gas budget and avoid oracle payment.\n        // Do not allow any non-view/non-pure coordinator functions to be called\n        // during the consumers callback code via reentrancyLock.\n        // Note that callWithExactGas will revert if we do not have sufficient gas\n        // to give the callee their requested amount.\n        sConfig.reentrancyLock = true;\n        (bool sent, ) = rc.sender.call(resp);\n        // bool success = callWithExactGas(rc.callbackGasLimit, rc.sender, resp);\n        //\n        sConfig.reentrancyLock = false;\n        return sent;\n    }\n\n    function cleanupAfterFulfillment(uint256 requestId) private returns (address[] memory) {\n        address[] memory oracles = sSubmission[requestId].oracles;\n\n        for (uint8 i = 0; i < oracles.length; ++i) {\n            delete sSubmission[requestId].submitted[oracles[i]];\n        }\n\n        delete sSubmission[requestId];\n        delete sRequestIdToCommitment[requestId];\n        delete sRequestOwner[requestId];\n\n        return oracles;\n    }\n\n    function uint256ToInt256(uint256[] memory arr) private pure returns (int256[] memory) {\n        int256[] memory responses = new int256[](arr.length);\n        for (uint256 i = 0; i < arr.length; i++) {\n            responses[i] = int256(uint256(arr[i]));\n        }\n        return responses;\n    }\n\n    function computeCommitment(\n        uint256 requestId,\n        uint256 blockNumber,\n        uint256 callbackGasLimit,\n        address sender,\n        bytes32 jobId\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(requestId, blockNumber, callbackGasLimit, sender, jobId));\n    }\n\n    function fulfillDataRequestUint256(\n        uint256 requestId,\n        uint256 response,\n        RequestCommitment memory rc\n    ) external nonReentrant {\n        validateDataResponse(rc, requestId);\n        sSubmission[requestId].submitted[msg.sender] = true;\n\n        address[] storage oracles = sSubmission[requestId].oracles;\n        oracles.push(msg.sender);\n        bytes memory resp = abi.encodeWithSelector(\n            ADCSConsumerFulfillUint256.rawFulfillDataRequest.selector,\n            requestId,\n            response\n        );\n        bool success = fulfill(resp, rc);\n        cleanupAfterFulfillment(requestId);\n\n        emit DataRequestFulfilledUint256(requestId, response, success);\n    }\n\n    function fulfillDataRequestBool(\n        uint256 requestId,\n        bool response,\n        RequestCommitment memory rc\n    ) external override {\n        validateDataResponse(rc, requestId);\n        sSubmission[requestId].submitted[msg.sender] = true;\n\n        address[] storage oracles = sSubmission[requestId].oracles;\n        oracles.push(msg.sender);\n        bytes memory resp = abi.encodeWithSelector(\n            ADCSConsumerFulfillBool.rawFulfillDataRequest.selector,\n            requestId,\n            response\n        );\n        bool success = fulfill(resp, rc);\n        cleanupAfterFulfillment(requestId);\n\n        emit DataRequestFulfilledBool(requestId, response, success);\n    }\n\n    function fulfillDataRequestBytes32(\n        uint256 requestId,\n        bytes32 response,\n        RequestCommitment memory rc\n    ) external override {\n        validateDataResponse(rc, requestId);\n        sSubmission[requestId].submitted[msg.sender] = true;\n\n        address[] storage oracles = sSubmission[requestId].oracles;\n        oracles.push(msg.sender);\n        bytes memory resp = abi.encodeWithSelector(\n            ADCSConsumerFulfillBytes32.rawFulfillDataRequest.selector,\n            requestId,\n            response\n        );\n        bool success = fulfill(resp, rc);\n        cleanupAfterFulfillment(requestId);\n\n        emit DataRequestFulfilledBytes32(requestId, response, success);\n    }\n\n    function fulfillDataRequestBytes(\n        uint256 requestId,\n        bytes memory response,\n        RequestCommitment memory rc\n    ) external override {\n        validateDataResponse(rc, requestId);\n        sSubmission[requestId].submitted[msg.sender] = true;\n\n        address[] storage oracles = sSubmission[requestId].oracles;\n        oracles.push(msg.sender);\n        bytes memory resp = abi.encodeWithSelector(\n            ADCSConsumerFulfillBytes.rawFulfillDataRequest.selector,\n            requestId,\n            response\n        );\n        bool success = fulfill(resp, rc);\n        cleanupAfterFulfillment(requestId);\n\n        emit DataRequestFulfilledBytes(requestId, response, success);\n    }\n\n    function fulfillDataRequestStringAndBool(\n        uint256 requestId,\n        StringAndBool memory response,\n        RequestCommitment memory rc\n    ) external override {\n        validateDataResponse(rc, requestId);\n        sSubmission[requestId].submitted[msg.sender] = true;\n\n        address[] storage oracles = sSubmission[requestId].oracles;\n        oracles.push(msg.sender);\n        bytes memory resp = abi.encodeWithSelector(\n            ADCSConsumerFulfillStringAndBool.rawFulfillDataRequest.selector,\n            requestId,\n            response\n        );\n        bool success = fulfill(resp, rc);\n        cleanupAfterFulfillment(requestId);\n\n        emit DataRequestFulfilledStringAndBool(requestId, response, success);\n    }\n}\n"
    },
    "src/CoordinatorBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/ICoordinatorBase.sol\";\n\nabstract contract CoordinatorBase is Ownable, ICoordinatorBase {\n    // 5k is plenty for an EXTCODESIZE call (2600) + warm CALL (100)\n    // and some arithmetic operations.\n    uint256 private constant GAS_FOR_CALL_EXACT_CHECK = 5_000;\n\n    address[] public sOracles;\n\n    /* requestID */\n    /* commitment */\n    mapping(uint256 => bytes32) internal sRequestIdToCommitment;\n\n    /* requestID */\n    /* owner */\n    mapping(uint256 => address) internal sRequestOwner;\n\n    struct Config {\n        uint256 maxGasLimit;\n        bool reentrancyLock;\n        // Gas to cover oracle payment after we calculate the payment.\n        // We make it configurable in case those operations are repriced.\n        uint256 gasAfterPaymentCalculation;\n    }\n    Config internal sConfig;\n\n    error Reentrant();\n    error NoCorrespondingRequest();\n    error NotRequestOwner();\n    error OracleAlreadyRegistered(address oracle);\n    error NoSuchOracle(address oracle);\n    error RefundFailure();\n    error InvalidConsumer(uint64 accId, address consumer);\n    error IncorrectCommitment();\n    error GasLimitTooBig(uint256 have, uint256 want);\n    error InsufficientPayment(uint256 have, uint256 want);\n\n    event ConfigSet(uint256 maxGasLimit, uint256 gasAfterPaymentCalculation);\n    event RequestCanceled(uint256 indexed requestId);\n\n    constructor() Ownable(_msgSender()) {}\n\n    modifier nonReentrant() {\n        if (sConfig.reentrancyLock) {\n            revert Reentrant();\n        }\n        _;\n    }\n\n    /**\n     * @inheritdoc ICoordinatorBase\n     */\n    function setConfig(uint256 maxGasLimit, uint256 gasAfterPaymentCalculation) external onlyOwner {\n        sConfig = Config({\n            maxGasLimit: maxGasLimit,\n            gasAfterPaymentCalculation: gasAfterPaymentCalculation,\n            reentrancyLock: false\n        });\n        emit ConfigSet(maxGasLimit, gasAfterPaymentCalculation);\n    }\n\n    function getConfig()\n        external\n        view\n        returns (uint256 maxGasLimit, uint256 gasAfterPaymentCalculation)\n    {\n        return (sConfig.maxGasLimit, sConfig.gasAfterPaymentCalculation);\n    }\n\n    /**\n     * @inheritdoc ICoordinatorBase\n     */\n    function getCommitment(uint256 requestId) external view returns (bytes32) {\n        return sRequestIdToCommitment[requestId];\n    }\n\n    /**\n     * @inheritdoc ICoordinatorBase\n     */\n    function cancelRequest(uint256 requestId) external {\n        if (!isValidRequestId(requestId)) {\n            revert NoCorrespondingRequest();\n        }\n\n        if (sRequestOwner[requestId] != msg.sender) {\n            revert NotRequestOwner();\n        }\n\n        delete sRequestIdToCommitment[requestId];\n        delete sRequestOwner[requestId];\n\n        emit RequestCanceled(requestId);\n    }\n\n    function calculateGasCost(uint256 startGas) internal view returns (uint256) {\n        return tx.gasprice * (sConfig.gasAfterPaymentCalculation + startGas - gasleft());\n    }\n\n    /**\n     * @dev calls target address with exactly gasAmount gas and data as calldata\n     * or reverts if at least gasAmount gas is not available.\n     */\n    function callWithExactGas(\n        uint256 gasAmount,\n        address target,\n        bytes memory data\n    ) internal returns (bool success) {\n        (success, ) = target.call{gas: gasAmount}(data);\n        return success;\n    }\n\n    function isValidRequestId(uint256 requestId) internal view returns (bool) {\n        if (sRequestIdToCommitment[requestId] != 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "src/interfaces/IADCSCoordinator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"./IADCSCoordinatorBase.sol\";\nimport \"./ICoordinatorBase.sol\";\n\ninterface IADCSCoordinator is IADCSCoordinatorBase, ICoordinatorBase {}\n"
    },
    "src/interfaces/IADCSCoordinatorBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"../libraries/ADCS.sol\";\n\ninterface IADCSCoordinatorBase {\n    // RequestCommitment holds information sent from off-chain oracle\n    // describing details of request.\n    struct RequestCommitment {\n        uint64 blockNum;\n        uint256 callbackGasLimit;\n        address sender;\n        bytes32 jobId;\n    }\n\n    struct StringAndBool {\n        string name;\n        bool response;\n    }\n\n    function requestData(\n        uint256 callbackGasLimit,\n        ADCS.Request memory req\n    ) external returns (uint256);\n\n    function fulfillDataRequestUint256(\n        uint256 requestId,\n        uint256 response,\n        RequestCommitment memory rc\n    ) external;\n\n    function fulfillDataRequestBool(\n        uint256 requestId,\n        bool response,\n        RequestCommitment memory rc\n    ) external;\n\n    function fulfillDataRequestBytes32(\n        uint256 requestId,\n        bytes32 response,\n        RequestCommitment memory rc\n    ) external;\n\n    function fulfillDataRequestBytes(\n        uint256 requestId,\n        bytes memory response,\n        RequestCommitment memory rc\n    ) external;\n\n    function fulfillDataRequestStringAndBool(\n        uint256 requestId,\n        StringAndBool memory response,\n        RequestCommitment memory rc\n    ) external;\n}\n"
    },
    "src/interfaces/IAlchemySmartAccount.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IAlchemySmartAccount {\n    function execute(address target, bytes calldata callData) external;\n    // Add other functions you need to interact with\n}\n"
    },
    "src/interfaces/ICoordinatorBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface ICoordinatorBase {\n    /**\n     * @notice Sets the configuration of the VRF coordinator\n     * @param maxGasLimit global max for request gas limit\n     * @param gasAfterPaymentCalculation gas used in doing accounting\n     * after completing the gas measurement\n     */\n    function setConfig(uint256 maxGasLimit, uint256 gasAfterPaymentCalculation) external;\n\n    function pendingRequestExists(address consumer, uint64 nonce) external view returns (bool);\n\n    /**\n     * @notice Get request commitment.\n     * @param requestId id of request\n     * @return commmitment value that can be used to determine whether\n     * a request is fulfilled or not. If `requestId` is valid and\n     * commitment equals to bytes32(0), the request was fulfilled.\n     */\n    function getCommitment(uint256 requestId) external view returns (bytes32);\n\n    /**\n     * @notice Canceling oracle request\n     * @param requestId - ID of the Oracle Request\n     */\n    function cancelRequest(uint256 requestId) external;\n}\n"
    },
    "src/interfaces/IERC1155Mintable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\ninterface IERC1155Mintable is IERC1155 {\n    function mint(address account, uint256 id, uint256 amount, bytes memory data) external;\n\n    function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) external;\n}\n"
    },
    "src/interfaces/IERC20Mintable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC20Mintable is IERC20 {\n    function mint(address _recipient, uint256 _amount) external;\n}\n"
    },
    "src/interfaces/IERC721Mintable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\ninterface IERC721Mintable is IERC721 {\n    function safeMint(address to) external;\n}\n"
    },
    "src/interfaces/ITypeAndVersion.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/TypeAndVersionInterface.sol\n\nabstract contract ITypeAndVersion {\n    function typeAndVersion() external pure virtual returns (string memory);\n}\n"
    },
    "src/libraries/ADCS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n// https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/Chainlink.sol\n\nimport {Buffer} from \"./Buffer.sol\";\nimport {CBOR} from \"./CBOR.sol\";\n\nlibrary ADCS {\n    uint256 internal constant defaultBufferSize = 256;\n\n    using CBOR for Buffer.buffer;\n\n    // structure for storing requests done off-chain\n    struct Request {\n        bytes32 id;\n        address callbackAddr;\n        bytes4 callbackFunc;\n        uint256 nonce;\n        Buffer.buffer buf;\n    }\n\n    /**\n     * @notice Initializes a request\n     * @dev Sets ID, callback address, and callback function\n     * @param self The uninitialized request\n     * @param jobId The Job Specification ID\n     * @param callbackAddr The callback address\n     * @param callbackFunc The callback function signature\n     * @return The initialized request\n     */\n    function initialize(\n        Request memory self,\n        bytes32 jobId,\n        address callbackAddr,\n        bytes4 callbackFunc\n    ) internal pure returns (ADCS.Request memory) {\n        Buffer.init(self.buf, defaultBufferSize);\n        self.id = jobId;\n        self.callbackAddr = callbackAddr;\n        self.callbackFunc = callbackFunc;\n        return self;\n    }\n\n    /**\n     * @notice sets the data for buffer\n     * @param _request the initialized request\n     * @param _data the CBOR data\n     */\n    function setBuffer(Request memory _request, bytes memory _data) internal pure {\n        Buffer.init(_request.buf, _data.length);\n        Buffer.append(_request.buf, _data);\n    }\n\n    /**\n     * @notice Adds a string value to the request in a key - value pair format\n     * @param self - the initalized request\n     * @param key - the name of the key\n     * @param value - the string value to add\n     */\n    function add(Request memory self, string memory key, string memory value) internal pure {\n        self.buf.encodeString(key);\n        self.buf.encodeString(value);\n    }\n\n    /**\n     * @notice Adds a byte value to the request in a key - value pair format\n     * @param _request - the initalized request\n     * @param _key - the name of the key\n     * @param _value - the bytes value to add\n     */\n    function addBytes(\n        Request memory _request,\n        string memory _key,\n        bytes memory _value\n    ) internal pure {\n        _request.buf.encodeString(_key);\n        _request.buf.encodeBytes(_value);\n    }\n\n    /**\n     * @notice Adds a Int256 value to the request in a key - value pair format\n     * @param _request - the initalized request\n     * @param _key - the name of the key\n     * @param _value - the int256 value to add\n     */\n    function addInt(Request memory _request, string memory _key, int256 _value) internal pure {\n        _request.buf.encodeString(_key);\n        _request.buf.encodeInt(_value);\n    }\n\n    /**\n     * @notice Adds a UInt256 value to the request in a key - value pair format\n     * @param _request - the initalized request\n     * @param _key - the name of the key\n     * @param _value - the uint256 value to add\n     */\n    function addUInt(Request memory _request, string memory _key, uint256 _value) internal pure {\n        _request.buf.encodeString(_key);\n        _request.buf.encodeUInt(_value);\n    }\n\n    /**\n     * @notice Adds an array of string value to the request in a key - value pair format\n     * @param _request - the initalized request\n     * @param _key - the name of the key\n     * @param _values - the array of string value to add\n     */\n    function addStringArray(\n        Request memory _request,\n        string memory _key,\n        string[] memory _values\n    ) internal pure {\n        _request.buf.encodeString(_key);\n        _request.buf.startArray();\n        for (uint256 i; i < _values.length; i++) {\n            _request.buf.encodeString(_values[i]);\n        }\n        _request.buf.endSequence();\n    }\n}\n"
    },
    "src/libraries/Buffer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev A library for working with mutable byte buffers in Solidity.\n *\n * Byte buffers are mutable and expandable, and provide a variety of primitives\n * for writing to them. At any time you can fetch a bytes object containing the\n * current contents of the buffer. The bytes object should not be stored between\n * operations, as it may change due to resizing of the buffer.\n */\nlibrary Buffer {\n    /**\n     * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n     *      a capacity. The capacity may be longer than the current value, in\n     *      which case it can be extended without the need to allocate more memory.\n     */\n    struct buffer {\n        bytes buf;\n        uint256 capacity;\n    }\n\n    /**\n     * @dev Initializes a buffer with an initial capacity.\n     * @param buf The buffer to initialize.\n     * @param capacity The number of bytes of space to allocate the buffer.\n     * @return The buffer, for chaining.\n     */\n    function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            mstore(0x40, add(32, add(ptr, capacity)))\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Initializes a new buffer from an existing bytes object.\n     *      Changes to the buffer may mutate the original value.\n     * @param b The bytes object to initialize the buffer with.\n     * @return A new buffer.\n     */\n    function fromBytes(bytes memory b) internal pure returns (buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint256 capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    function max(uint256 a, uint256 b) private pure returns (uint256) {\n        if (a > b) {\n            return a;\n        }\n        return b;\n    }\n\n    /**\n     * @dev Sets buffer length to 0.\n     * @param buf The buffer to truncate.\n     * @return The original buffer, for chaining..\n     */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The start offset to write to.\n     * @param data The data to append.\n     * @param len The number of bytes to copy.\n     * @return The original buffer, for chaining.\n     */\n    function write(\n        buffer memory buf,\n        uint256 off,\n        bytes memory data,\n        uint256 len\n    ) internal pure returns (buffer memory) {\n        require(len <= data.length);\n\n        if (off + len > buf.capacity) {\n            resize(buf, max(buf.capacity, len + off) * 2);\n        }\n\n        uint256 dest;\n        uint256 src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(add(len, off), buflen) {\n                mstore(bufptr, add(len, off))\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint256 mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n     * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @param len The number of bytes to copy.\n     * @return The original buffer, for chaining.\n     */\n    function append(\n        buffer memory buf,\n        bytes memory data,\n        uint256 len\n    ) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, len);\n    }\n\n    /**\n     * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, data.length);\n    }\n\n    /**\n     * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n     *      capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The offset to write the byte at.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function writeUint8(\n        buffer memory buf,\n        uint256 off,\n        uint8 data\n    ) internal pure returns (buffer memory) {\n        if (off >= buf.capacity) {\n            resize(buf, buf.capacity * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if eq(off, buflen) {\n                mstore(bufptr, add(buflen, 1))\n            }\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n     *      capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\n        return writeUint8(buf, buf.buf.length, data);\n    }\n\n    /**\n     * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n     *      exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The offset to write at.\n     * @param data The data to append.\n     * @param len The number of bytes to write (left-aligned).\n     * @return The original buffer, for chaining.\n     */\n    function write(\n        buffer memory buf,\n        uint256 off,\n        bytes32 data,\n        uint256 len\n    ) private pure returns (buffer memory) {\n        if (len + off > buf.capacity) {\n            resize(buf, (len + off) * 2);\n        }\n\n        unchecked {\n            uint256 mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + off + len\n                let dest := add(add(bufptr, off), len)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(add(off, len), mload(bufptr)) {\n                    mstore(bufptr, add(off, len))\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n     *      capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The offset to write at.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function writeBytes20(\n        buffer memory buf,\n        uint256 off,\n        bytes20 data\n    ) internal pure returns (buffer memory) {\n        return write(buf, off, bytes32(data), 20);\n    }\n\n    /**\n     * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer, for chhaining.\n     */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, bytes32(data), 20);\n    }\n\n    /**\n     * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer, for chaining.\n     */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, 32);\n    }\n\n    /**\n     * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n     *      the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param off The offset to write at.\n     * @param data The data to append.\n     * @param len The number of bytes to write (right-aligned).\n     * @return The original buffer, for chaining.\n     */\n    function writeInt(\n        buffer memory buf,\n        uint256 off,\n        uint256 data,\n        uint256 len\n    ) private pure returns (buffer memory) {\n        if (len + off > buf.capacity) {\n            resize(buf, (len + off) * 2);\n        }\n\n        uint256 mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + off + sizeof(buffer length) + len\n            let dest := add(add(bufptr, off), len)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(add(off, len), mload(bufptr)) {\n                mstore(bufptr, add(off, len))\n            }\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     * exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer.\n     */\n    function appendInt(\n        buffer memory buf,\n        uint256 data,\n        uint256 len\n    ) internal pure returns (buffer memory) {\n        return writeInt(buf, buf.buf.length, data, len);\n    }\n}\n"
    },
    "src/libraries/CBOR.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n// https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vendor/CBORChainlink.sol\n\nimport {Buffer} from \"./Buffer.sol\";\n\n// Encoding library for Binary Object Representation\nlibrary CBOR {\n    using Buffer for Buffer.buffer;\n\n    // DECLARE TYPES FOR EASIER REFERENCE OF VARIABLE TYPE\n    uint8 private constant MAJOR_TYPE_INT = 0;\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\n    uint8 private constant MAJOR_TYPE_STRING = 3;\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\n    uint8 private constant MAJOR_TYPE_MAP = 5;\n    uint8 private constant MAJOR_TYPE_TAG = 6;\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n    uint8 private constant TAG_TYPE_BIGNUM = 2;\n    uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n    function encodeFixedNumeric(Buffer.buffer memory buf, uint8 major, uint64 value) private pure {\n        if (value <= 23) {\n            buf.appendUint8(uint8((major << 5) | value));\n        } else if (value <= 0xFF) {\n            buf.appendUint8(uint8((major << 5) | 24));\n            buf.appendInt(value, 1);\n        } else if (value <= 0xFFFF) {\n            buf.appendUint8(uint8((major << 5) | 25));\n            buf.appendInt(value, 2);\n        } else if (value <= 0xFFFFFFFF) {\n            buf.appendUint8(uint8((major << 5) | 26));\n            buf.appendInt(value, 4);\n        } else {\n            buf.appendUint8(uint8((major << 5) | 27));\n            buf.appendInt(value, 8);\n        }\n    }\n\n    function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private pure {\n        buf.appendUint8(uint8((major << 5) | 31));\n    }\n\n    function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {\n        if (value > 0xFFFFFFFFFFFFFFFF) {\n            encodeBigNum(buf, value);\n        } else {\n            encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n        }\n    }\n\n    function encodeInt(Buffer.buffer memory buf, int value) internal pure {\n        if (value < -0x10000000000000000) {\n            encodeSignedBigNum(buf, value);\n        } else if (value > 0xFFFFFFFFFFFFFFFF) {\n            encodeBigNum(buf, uint(value));\n        } else if (value >= 0) {\n            encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\n        } else {\n            encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\n        }\n    }\n\n    function encodeBytes(Buffer.buffer memory buf, bytes memory value) internal pure {\n        encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n        buf.append(value);\n    }\n\n    function encodeBigNum(Buffer.buffer memory buf, uint value) internal pure {\n        buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n        encodeBytes(buf, abi.encode(value));\n    }\n\n    function encodeSignedBigNum(Buffer.buffer memory buf, int input) internal pure {\n        buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\n        encodeBytes(buf, abi.encode(uint256(-1 - input)));\n    }\n\n    function encodeString(Buffer.buffer memory buf, string memory value) internal pure {\n        encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n        buf.append(bytes(value));\n    }\n\n    function startArray(Buffer.buffer memory buf) internal pure {\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n    }\n\n    function startMap(Buffer.buffer memory buf) internal pure {\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n    }\n\n    function endSequence(Buffer.buffer memory buf) internal pure {\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n    }\n}\n"
    },
    "src/libraries/ecc/EllipticCurve.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n// https://github.com/witnet/elliptic-curve-solidity/blob/master/contracts/EllipticCurve.sol\n\n/**\n * @title Elliptic Curve Library\n * @dev Library providing arithmetic operations over elliptic curves.\n * This library does not check whether the inserted points belong to the curve\n * `isOnCurve` function should be used by the library user to check the aforementioned statement.\n * @author Witnet Foundation\n */\nlibrary EllipticCurve {\n    // Pre-computed constant for 2 ** 255\n    uint256 private constant U255_MAX_PLUS_1 =\n        57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    /// @dev Modular euclidean inverse of a number (mod p).\n    /// @param _x The number\n    /// @param _pp The modulus\n    /// @return q such that x*q = 1 (mod _pp)\n    function invMod(uint256 _x, uint256 _pp) internal pure returns (uint256) {\n        require(_x != 0 && _x != _pp && _pp != 0, \"Invalid number\");\n        uint256 q = 0;\n        uint256 newT = 1;\n        uint256 r = _pp;\n        uint256 t;\n        while (_x != 0) {\n            t = r / _x;\n            (q, newT) = (newT, addmod(q, (_pp - mulmod(t, newT, _pp)), _pp));\n            (r, _x) = (_x, r - t * _x);\n        }\n\n        return q;\n    }\n\n    /// @dev Modular exponentiation, b^e % _pp.\n    /// Source: https://github.com/androlo/standard-contracts/blob/master/contracts/src/crypto/ECCMath.sol\n    /// @param _base base\n    /// @param _exp exponent\n    /// @param _pp modulus\n    /// @return r such that r = b**e (mod _pp)\n    function expMod(uint256 _base, uint256 _exp, uint256 _pp) internal pure returns (uint256) {\n        require(_pp != 0, \"Modulus is zero\");\n\n        if (_base == 0) return 0;\n        if (_exp == 0) return 1;\n\n        uint256 r = 1;\n        uint256 bit = U255_MAX_PLUS_1;\n        assembly {\n            for {\n\n            } gt(bit, 0) {\n\n            } {\n                r := mulmod(mulmod(r, r, _pp), exp(_base, iszero(iszero(and(_exp, bit)))), _pp)\n                r := mulmod(\n                    mulmod(r, r, _pp),\n                    exp(_base, iszero(iszero(and(_exp, div(bit, 2))))),\n                    _pp\n                )\n                r := mulmod(\n                    mulmod(r, r, _pp),\n                    exp(_base, iszero(iszero(and(_exp, div(bit, 4))))),\n                    _pp\n                )\n                r := mulmod(\n                    mulmod(r, r, _pp),\n                    exp(_base, iszero(iszero(and(_exp, div(bit, 8))))),\n                    _pp\n                )\n                bit := div(bit, 16)\n            }\n        }\n\n        return r;\n    }\n\n    /// @dev Converts a point (x, y, z) expressed in Jacobian coordinates to affine coordinates (x', y', 1).\n    /// @param _x coordinate x\n    /// @param _y coordinate y\n    /// @param _z coordinate z\n    /// @param _pp the modulus\n    /// @return (x', y') affine coordinates\n    function toAffine(\n        uint256 _x,\n        uint256 _y,\n        uint256 _z,\n        uint256 _pp\n    ) internal pure returns (uint256, uint256) {\n        uint256 zInv = invMod(_z, _pp);\n        uint256 zInv2 = mulmod(zInv, zInv, _pp);\n        uint256 x2 = mulmod(_x, zInv2, _pp);\n        uint256 y2 = mulmod(_y, mulmod(zInv, zInv2, _pp), _pp);\n\n        return (x2, y2);\n    }\n\n    /// @dev Derives the y coordinate from a compressed-format point x [[SEC-1]](https://www.secg.org/SEC1-Ver-1.0.pdf).\n    /// @param _prefix parity byte (0x02 even, 0x03 odd)\n    /// @param _x coordinate x\n    /// @param _aa constant of curve\n    /// @param _bb constant of curve\n    /// @param _pp the modulus\n    /// @return y coordinate y\n    function deriveY(\n        uint8 _prefix,\n        uint256 _x,\n        uint256 _aa,\n        uint256 _bb,\n        uint256 _pp\n    ) internal pure returns (uint256) {\n        require(_prefix == 0x02 || _prefix == 0x03, \"Invalid compressed EC point prefix\");\n\n        // x^3 + ax + b\n        uint256 y2 = addmod(\n            mulmod(_x, mulmod(_x, _x, _pp), _pp),\n            addmod(mulmod(_x, _aa, _pp), _bb, _pp),\n            _pp\n        );\n        y2 = expMod(y2, (_pp + 1) / 4, _pp);\n        // uint256 cmp = yBit ^ y_ & 1;\n        uint256 y = (y2 + _prefix) % 2 == 0 ? y2 : _pp - y2;\n\n        return y;\n    }\n\n    /// @dev Check whether point (x,y) is on curve defined by a, b, and _pp.\n    /// @param _x coordinate x of P1\n    /// @param _y coordinate y of P1\n    /// @param _aa constant of curve\n    /// @param _bb constant of curve\n    /// @param _pp the modulus\n    /// @return true if x,y in the curve, false else\n    function isOnCurve(\n        uint256 _x,\n        uint256 _y,\n        uint256 _aa,\n        uint256 _bb,\n        uint256 _pp\n    ) internal pure returns (bool) {\n        if (0 == _x || _x >= _pp || 0 == _y || _y >= _pp) {\n            return false;\n        }\n        // y^2\n        uint256 lhs = mulmod(_y, _y, _pp);\n        // x^3\n        uint256 rhs = mulmod(mulmod(_x, _x, _pp), _x, _pp);\n        if (_aa != 0) {\n            // x^3 + a*x\n            rhs = addmod(rhs, mulmod(_x, _aa, _pp), _pp);\n        }\n        if (_bb != 0) {\n            // x^3 + a*x + b\n            rhs = addmod(rhs, _bb, _pp);\n        }\n\n        return lhs == rhs;\n    }\n\n    /// @dev Calculate inverse (x, -y) of point (x, y).\n    /// @param _x coordinate x of P1\n    /// @param _y coordinate y of P1\n    /// @param _pp the modulus\n    /// @return (x, -y)\n    function ecInv(uint256 _x, uint256 _y, uint256 _pp) internal pure returns (uint256, uint256) {\n        return (_x, (_pp - _y) % _pp);\n    }\n\n    /// @dev Add two points (x1, y1) and (x2, y2) in affine coordinates.\n    /// @param _x1 coordinate x of P1\n    /// @param _y1 coordinate y of P1\n    /// @param _x2 coordinate x of P2\n    /// @param _y2 coordinate y of P2\n    /// @param _aa constant of the curve\n    /// @param _pp the modulus\n    /// @return (qx, qy) = P1+P2 in affine coordinates\n    function ecAdd(\n        uint256 _x1,\n        uint256 _y1,\n        uint256 _x2,\n        uint256 _y2,\n        uint256 _aa,\n        uint256 _pp\n    ) internal pure returns (uint256, uint256) {\n        uint256 x = 0;\n        uint256 y = 0;\n        uint256 z = 0;\n\n        // Double if x1==x2 else add\n        if (_x1 == _x2) {\n            // y1 = -y2 mod p\n            if (addmod(_y1, _y2, _pp) == 0) {\n                return (0, 0);\n            } else {\n                // P1 = P2\n                (x, y, z) = jacDouble(_x1, _y1, 1, _aa, _pp);\n            }\n        } else {\n            (x, y, z) = jacAdd(_x1, _y1, 1, _x2, _y2, 1, _pp);\n        }\n        // Get back to affine\n        return toAffine(x, y, z, _pp);\n    }\n\n    /// @dev Substract two points (x1, y1) and (x2, y2) in affine coordinates.\n    /// @param _x1 coordinate x of P1\n    /// @param _y1 coordinate y of P1\n    /// @param _x2 coordinate x of P2\n    /// @param _y2 coordinate y of P2\n    /// @param _aa constant of the curve\n    /// @param _pp the modulus\n    /// @return (qx, qy) = P1-P2 in affine coordinates\n    function ecSub(\n        uint256 _x1,\n        uint256 _y1,\n        uint256 _x2,\n        uint256 _y2,\n        uint256 _aa,\n        uint256 _pp\n    ) internal pure returns (uint256, uint256) {\n        // invert square\n        (uint256 x, uint256 y) = ecInv(_x2, _y2, _pp);\n        // P1-square\n        return ecAdd(_x1, _y1, x, y, _aa, _pp);\n    }\n\n    /// @dev Multiply point (x1, y1, z1) times d in affine coordinates.\n    /// @param _k scalar to multiply\n    /// @param _x coordinate x of P1\n    /// @param _y coordinate y of P1\n    /// @param _aa constant of the curve\n    /// @param _pp the modulus\n    /// @return (qx, qy) = d*P in affine coordinates\n    function ecMul(\n        uint256 _k,\n        uint256 _x,\n        uint256 _y,\n        uint256 _aa,\n        uint256 _pp\n    ) internal pure returns (uint256, uint256) {\n        // Jacobian multiplication\n        (uint256 x1, uint256 y1, uint256 z1) = jacMul(_k, _x, _y, 1, _aa, _pp);\n        // Get back to affine\n        return toAffine(x1, y1, z1, _pp);\n    }\n\n    /// @dev Adds two points (x1, y1, z1) and (x2 y2, z2).\n    /// @param _x1 coordinate x of P1\n    /// @param _y1 coordinate y of P1\n    /// @param _z1 coordinate z of P1\n    /// @param _x2 coordinate x of square\n    /// @param _y2 coordinate y of square\n    /// @param _z2 coordinate z of square\n    /// @param _pp the modulus\n    /// @return (qx, qy, qz) P1+square in Jacobian\n    function jacAdd(\n        uint256 _x1,\n        uint256 _y1,\n        uint256 _z1,\n        uint256 _x2,\n        uint256 _y2,\n        uint256 _z2,\n        uint256 _pp\n    ) internal pure returns (uint256, uint256, uint256) {\n        if (_x1 == 0 && _y1 == 0) return (_x2, _y2, _z2);\n        if (_x2 == 0 && _y2 == 0) return (_x1, _y1, _z1);\n\n        // We follow the equations described in https://pdfs.semanticscholar.org/5c64/29952e08025a9649c2b0ba32518e9a7fb5c2.pdf Section 5\n        uint256[4] memory zs; // z1^2, z1^3, z2^2, z2^3\n        zs[0] = mulmod(_z1, _z1, _pp);\n        zs[1] = mulmod(_z1, zs[0], _pp);\n        zs[2] = mulmod(_z2, _z2, _pp);\n        zs[3] = mulmod(_z2, zs[2], _pp);\n\n        // u1, s1, u2, s2\n        zs = [\n            mulmod(_x1, zs[2], _pp),\n            mulmod(_y1, zs[3], _pp),\n            mulmod(_x2, zs[0], _pp),\n            mulmod(_y2, zs[1], _pp)\n        ];\n\n        // In case of zs[0] == zs[2] && zs[1] == zs[3], double function should be used\n        require(zs[0] != zs[2] || zs[1] != zs[3], \"Use jacDouble function instead\");\n\n        uint256[4] memory hr;\n        //h\n        hr[0] = addmod(zs[2], _pp - zs[0], _pp);\n        //r\n        hr[1] = addmod(zs[3], _pp - zs[1], _pp);\n        //h^2\n        hr[2] = mulmod(hr[0], hr[0], _pp);\n        // h^3\n        hr[3] = mulmod(hr[2], hr[0], _pp);\n        // qx = -h^3  -2u1h^2+r^2\n        uint256 qx = addmod(mulmod(hr[1], hr[1], _pp), _pp - hr[3], _pp);\n        qx = addmod(qx, _pp - mulmod(2, mulmod(zs[0], hr[2], _pp), _pp), _pp);\n        // qy = -s1*z1*h^3+r(u1*h^2 -x^3)\n        uint256 qy = mulmod(hr[1], addmod(mulmod(zs[0], hr[2], _pp), _pp - qx, _pp), _pp);\n        qy = addmod(qy, _pp - mulmod(zs[1], hr[3], _pp), _pp);\n        // qz = h*z1*z2\n        uint256 qz = mulmod(hr[0], mulmod(_z1, _z2, _pp), _pp);\n        return (qx, qy, qz);\n    }\n\n    /// @dev Doubles a points (x, y, z).\n    /// @param _x coordinate x of P1\n    /// @param _y coordinate y of P1\n    /// @param _z coordinate z of P1\n    /// @param _aa the a scalar in the curve equation\n    /// @param _pp the modulus\n    /// @return (qx, qy, qz) 2P in Jacobian\n    function jacDouble(\n        uint256 _x,\n        uint256 _y,\n        uint256 _z,\n        uint256 _aa,\n        uint256 _pp\n    ) internal pure returns (uint256, uint256, uint256) {\n        if (_z == 0) return (_x, _y, _z);\n\n        // We follow the equations described in https://pdfs.semanticscholar.org/5c64/29952e08025a9649c2b0ba32518e9a7fb5c2.pdf Section 5\n        // Note: there is a bug in the paper regarding the m parameter, M=3*(x1^2)+a*(z1^4)\n        // x, y, z at this point represent the squares of _x, _y, _z\n        uint256 x = mulmod(_x, _x, _pp); //x1^2\n        uint256 y = mulmod(_y, _y, _pp); //y1^2\n        uint256 z = mulmod(_z, _z, _pp); //z1^2\n\n        // s\n        uint256 s = mulmod(4, mulmod(_x, y, _pp), _pp);\n        // m\n        uint256 m = addmod(mulmod(3, x, _pp), mulmod(_aa, mulmod(z, z, _pp), _pp), _pp);\n\n        // x, y, z at this point will be reassigned and rather represent qx, qy, qz from the paper\n        // This allows to reduce the gas cost and stack footprint of the algorithm\n        // qx\n        x = addmod(mulmod(m, m, _pp), _pp - addmod(s, s, _pp), _pp);\n        // qy = -8*y1^4 + M(S-T)\n        y = addmod(\n            mulmod(m, addmod(s, _pp - x, _pp), _pp),\n            _pp - mulmod(8, mulmod(y, y, _pp), _pp),\n            _pp\n        );\n        // qz = 2*y1*z1\n        z = mulmod(2, mulmod(_y, _z, _pp), _pp);\n\n        return (x, y, z);\n    }\n\n    /// @dev Multiply point (x, y, z) times d.\n    /// @param _d scalar to multiply\n    /// @param _x coordinate x of P1\n    /// @param _y coordinate y of P1\n    /// @param _z coordinate z of P1\n    /// @param _aa constant of curve\n    /// @param _pp the modulus\n    /// @return (qx, qy, qz) d*P1 in Jacobian\n    function jacMul(\n        uint256 _d,\n        uint256 _x,\n        uint256 _y,\n        uint256 _z,\n        uint256 _aa,\n        uint256 _pp\n    ) internal pure returns (uint256, uint256, uint256) {\n        // Early return in case that `_d == 0`\n        if (_d == 0) {\n            return (_x, _y, _z);\n        }\n\n        uint256 remaining = _d;\n        uint256 qx = 0;\n        uint256 qy = 0;\n        uint256 qz = 1;\n\n        // Double and add algorithm\n        while (remaining != 0) {\n            if ((remaining & 1) != 0) {\n                (qx, qy, qz) = jacAdd(qx, qy, qz, _x, _y, _z, _pp);\n            }\n            remaining = remaining / 2;\n            (_x, _y, _z) = jacDouble(_x, _y, _z, _aa, _pp);\n        }\n        return (qx, qy, qz);\n    }\n}\n"
    },
    "src/libraries/Median.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n// https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/Median.sol\n\nlibrary Median {\n    int256 constant INT_MAX = 2 ** 255 - 1;\n\n    /**\n     * @notice Returns the sorted middle, or the average of the two middle indexed items if the\n     * array has an even number of elements.\n     * @dev The list passed as an argument isn't modified.\n     * @dev This algorithm has expected runtime O(n), but for adversarially chosen inputs\n     * the runtime is O(n^2).\n     * @param list The list of elements to compare\n     */\n    function calculate(int256[] memory list) internal pure returns (int256) {\n        return calculateInplace(copy(list));\n    }\n\n    /**\n     * @notice See documentation for function calculate.\n     * @dev The list passed as an argument may be permuted.\n     */\n    function calculateInplace(int256[] memory list) internal pure returns (int256) {\n        require(list.length > 0, \"list must not be empty\");\n        uint256 len = list.length;\n        uint256 middleIndex = len / 2;\n        if (len % 2 == 0) {\n            int256 median1;\n            int256 median2;\n            (median1, median2) = quickselectTwo(list, 0, len - 1, middleIndex - 1, middleIndex);\n            return avg(median1, median2);\n        } else {\n            return quickselect(list, 0, len - 1, middleIndex);\n        }\n    }\n\n    /**\n     * @notice Computes average of two signed integers.\n     * @dev If the result is not an integer, it is rounded towards\n     * @dev zero. For example, avg(-3, -4) = -3\n     * @dev Since Solidity v0.8.0 arithmetic operations revert on\n     * @dev underflow and overflow. We do not need to check for it\n     * @dev manually.\n     */\n    function avg(int256 _a, int256 _b) internal pure returns (int256) {\n        if ((_a < 0 && _b > 0) || (_a > 0 && _b < 0)) {\n            return (_a + _b) / 2;\n        }\n        int256 remainder = ((_a % 2) + (_b % 2)) / 2;\n        return (_a / 2) + (_b / 2) + remainder;\n    }\n\n    /**\n     * @notice Maximum length of list that shortSelectTwo can handle\n     */\n    uint256 constant SHORTSELECTTWO_MAX_LENGTH = 7;\n\n    /**\n     * @notice Select the k1-th and k2-th element from list of length at most 7\n     * @dev Uses an optimal sorting network\n     */\n    function shortSelectTwo(\n        int256[] memory list,\n        uint256 lo,\n        uint256 hi,\n        uint256 k1,\n        uint256 k2\n    ) private pure returns (int256 k1th, int256 k2th) {\n        // Uses an optimal sorting network (https://en.wikipedia.org/wiki/Sorting_network)\n        // for lists of length 7. Network layout is taken from\n        // http://jgamble.ripco.net/cgi-bin/nw.cgi?inputs=7&algorithm=hibbard&output=svg\n\n        uint256 len = hi + 1 - lo;\n        int256 x0 = list[lo + 0];\n        int256 x1 = 1 < len ? list[lo + 1] : INT_MAX;\n        int256 x2 = 2 < len ? list[lo + 2] : INT_MAX;\n        int256 x3 = 3 < len ? list[lo + 3] : INT_MAX;\n        int256 x4 = 4 < len ? list[lo + 4] : INT_MAX;\n        int256 x5 = 5 < len ? list[lo + 5] : INT_MAX;\n        int256 x6 = 6 < len ? list[lo + 6] : INT_MAX;\n\n        if (x0 > x1) {\n            (x0, x1) = (x1, x0);\n        }\n        if (x2 > x3) {\n            (x2, x3) = (x3, x2);\n        }\n        if (x4 > x5) {\n            (x4, x5) = (x5, x4);\n        }\n        if (x0 > x2) {\n            (x0, x2) = (x2, x0);\n        }\n        if (x1 > x3) {\n            (x1, x3) = (x3, x1);\n        }\n        if (x4 > x6) {\n            (x4, x6) = (x6, x4);\n        }\n        if (x1 > x2) {\n            (x1, x2) = (x2, x1);\n        }\n        if (x5 > x6) {\n            (x5, x6) = (x6, x5);\n        }\n        if (x0 > x4) {\n            (x0, x4) = (x4, x0);\n        }\n        if (x1 > x5) {\n            (x1, x5) = (x5, x1);\n        }\n        if (x2 > x6) {\n            (x2, x6) = (x6, x2);\n        }\n        if (x1 > x4) {\n            (x1, x4) = (x4, x1);\n        }\n        if (x3 > x6) {\n            (x3, x6) = (x6, x3);\n        }\n        if (x2 > x4) {\n            (x2, x4) = (x4, x2);\n        }\n        if (x3 > x5) {\n            (x3, x5) = (x5, x3);\n        }\n        if (x3 > x4) {\n            (x3, x4) = (x4, x3);\n        }\n\n        uint256 index1 = k1 - lo;\n        if (index1 == 0) {\n            k1th = x0;\n        } else if (index1 == 1) {\n            k1th = x1;\n        } else if (index1 == 2) {\n            k1th = x2;\n        } else if (index1 == 3) {\n            k1th = x3;\n        } else if (index1 == 4) {\n            k1th = x4;\n        } else if (index1 == 5) {\n            k1th = x5;\n        } else if (index1 == 6) {\n            k1th = x6;\n        } else {\n            revert(\"k1 out of bounds\");\n        }\n\n        uint256 index2 = k2 - lo;\n        if (k1 == k2) {\n            return (k1th, k1th);\n        } else if (index2 == 0) {\n            return (k1th, x0);\n        } else if (index2 == 1) {\n            return (k1th, x1);\n        } else if (index2 == 2) {\n            return (k1th, x2);\n        } else if (index2 == 3) {\n            return (k1th, x3);\n        } else if (index2 == 4) {\n            return (k1th, x4);\n        } else if (index2 == 5) {\n            return (k1th, x5);\n        } else if (index2 == 6) {\n            return (k1th, x6);\n        } else {\n            revert(\"k2 out of bounds\");\n        }\n    }\n\n    /**\n     * @notice Selects the k-th ranked element from list, looking only at indices between lo and hi\n     * (inclusive). Modifies list in-place.\n     */\n    function quickselect(\n        int256[] memory list,\n        uint256 lo,\n        uint256 hi,\n        uint256 k\n    ) private pure returns (int256 kth) {\n        require(lo <= k);\n        require(k <= hi);\n        while (lo < hi) {\n            if (hi - lo < SHORTSELECTTWO_MAX_LENGTH) {\n                int256 ignore;\n                (kth, ignore) = shortSelectTwo(list, lo, hi, k, k);\n                return kth;\n            }\n            uint256 pivotIndex = partition(list, lo, hi);\n            if (k <= pivotIndex) {\n                // since pivotIndex < (original hi passed to partition),\n                // termination is guaranteed in this case\n                hi = pivotIndex;\n            } else {\n                // since (original lo passed to partition) <= pivotIndex,\n                // termination is guaranteed in this case\n                lo = pivotIndex + 1;\n            }\n        }\n        return list[lo];\n    }\n\n    /**\n     * @notice Selects the k1-th and k2-th ranked elements from list, looking only at indices between\n     * lo and hi (inclusive). Modifies list in-place.\n     */\n    function quickselectTwo(\n        int256[] memory list,\n        uint256 lo,\n        uint256 hi,\n        uint256 k1,\n        uint256 k2 // for testing\n    ) internal pure returns (int256 k1th, int256 k2th) {\n        require(k1 < k2);\n        require(lo <= k1 && k1 <= hi);\n        require(lo <= k2 && k2 <= hi);\n\n        while (true) {\n            if (hi - lo < SHORTSELECTTWO_MAX_LENGTH) {\n                return shortSelectTwo(list, lo, hi, k1, k2);\n            }\n            uint256 pivotIdx = partition(list, lo, hi);\n            if (k2 <= pivotIdx) {\n                hi = pivotIdx;\n            } else if (pivotIdx < k1) {\n                lo = pivotIdx + 1;\n            } else {\n                assert(k1 <= pivotIdx && pivotIdx < k2);\n                k1th = quickselect(list, lo, pivotIdx, k1);\n                k2th = quickselect(list, pivotIdx + 1, hi, k2);\n                return (k1th, k2th);\n            }\n        }\n    }\n\n    /**\n     * @notice Partitions list in-place using Hoare's partitioning scheme.\n     * Only elements of list between indices lo and hi (inclusive) will be modified.\n     * Returns an index i, such that:\n     * - lo <= i < hi\n     * - forall j in [lo, i]. list[j] <= list[i]\n     * - forall j in [i, hi]. list[i] <= list[j]\n     */\n    function partition(\n        int256[] memory list,\n        uint256 lo,\n        uint256 hi\n    ) private pure returns (uint256) {\n        // We don't care about overflow of the addition, because it would require a list\n        // larger than any feasible computer's memory.\n        int256 pivot = list[(lo + hi) / 2];\n        unchecked {\n            lo -= 1; // this can underflow. that's intentional.\n        }\n        hi += 1;\n\n        while (true) {\n            do {\n                unchecked {\n                    lo += 1;\n                }\n            } while (list[lo] < pivot);\n            do {\n                hi -= 1;\n            } while (list[hi] > pivot);\n            if (lo < hi) {\n                (list[lo], list[hi]) = (list[hi], list[lo]);\n            } else {\n                // Let orig_lo and orig_hi be the original values of lo and hi passed to partition.\n                // Then, hi < orig_hi, because hi decreases *strictly* monotonically\n                // in each loop iteration and\n                // - either list[orig_hi] > pivot, in which case the first loop iteration\n                //   will achieve hi < orig_hi;\n                // - or list[orig_hi] <= pivot, in which case at least two loop iterations are\n                //   needed:\n                //   - lo will have to stop at least once in the interval\n                //     [orig_lo, (orig_lo + orig_hi)/2]\n                //   - (orig_lo + orig_hi)/2 < orig_hi\n                return hi;\n            }\n        }\n        revert();\n    }\n\n    /**\n     * @notice Makes an in-memory copy of the array passed in\n     * @param list Reference to the array to be copied\n     */\n    function copy(int256[] memory list) private pure returns (int256[] memory) {\n        int256[] memory list2 = new int256[](list.length);\n        for (uint256 i = 0; i < list.length; i++) {\n            list2[i] = list[i];\n        }\n        return list2;\n    }\n}\n"
    },
    "src/MemeCoinsManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract MemeCoinsManager {\n    address public owner;\n    \n    event MemeCoinBought(address indexed buyer, address indexed tokenAddress, uint256 amount);\n    event MemeCoinWithdrawn(address indexed receiver, uint256 totalAmount);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can call this function\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    mapping(address => uint256) public memecoinBalances;\n\n    function getMemecoins() public view returns (address[] memory, uint256[] memory) {\n        address[] memory addresses = new address[](3);\n        uint256[] memory balances = new uint256[](3);\n\n        addresses[0] = address(0x1111111111111111111111111111111111111111);\n        addresses[1] = address(0x2222222222222222222222222222222222222222);\n        addresses[2] = address(0x3333333333333333333333333333333333333333);\n\n        balances[0] = memecoinBalances[addresses[0]];\n        balances[1] = memecoinBalances[addresses[1]];\n        balances[2] = memecoinBalances[addresses[2]];\n\n        return (addresses, balances);\n    }\n\n    function buyMemeCoin(address memecoinAddress, uint256 amount) public {\n        require(amount > 0, \"Amount must be greater than 0\");\n        emit MemeCoinBought(msg.sender, memecoinAddress, amount);\n    }\n\n    function withdraw() public onlyOwner {\n        emit MemeCoinWithdrawn(msg.sender, 6000000);\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"New owner cannot be the zero address\");\n        owner = newOwner;\n    }\n}\n"
    },
    "src/mock/MockADCSConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../ADCSConsumerFulfill.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MockADCSConsumer is\n    ADCSConsumerFulfillUint256,\n    ADCSConsumerFulfillBool,\n    ADCSConsumerFulfillBytes32,\n    ADCSConsumerFulfillBytes,\n    Ownable\n{\n    using ADCS for ADCS.Request;\n    uint256 public lastUint256;\n    bool public lastBool;\n    bytes32 public lastBytes32;\n    bytes public lastBytes;\n\n    event DataRequestedUint256(uint256 indexed requestId);\n    event DataRequestedBool(uint256 indexed requestId);\n    event DataRequestedBytes32(uint256 indexed requestId);\n    event DataRequestedBytes(uint256 indexed requestId);\n\n    constructor(address _coordinator) ADCSConsumerBase(_coordinator) Ownable(_msgSender()) {}\n\n    function requestUint256Data(\n        uint32 _callbackGasLimit,\n        bytes32 _jobId,\n        string memory _from,\n        string memory _to\n    ) external returns (uint256 requestId) {\n        bytes32 typeId = keccak256(abi.encodePacked(\"uint256\"));\n        ADCS.Request memory req = buildRequest(_jobId, typeId);\n        req.add(\"from\", _from);\n        req.add(\"to\", _to);\n        requestId = COORDINATOR.requestData(_callbackGasLimit, req);\n        emit DataRequestedUint256(requestId);\n    }\n\n    function requestBoolData(\n        uint32 _callbackGasLimit,\n        bytes32 _jobId\n    ) external returns (uint256 requestId) {\n        bytes32 typeId = keccak256(abi.encodePacked(\"bool\"));\n        ADCS.Request memory req = buildRequest(_jobId, typeId);\n        requestId = COORDINATOR.requestData(_callbackGasLimit, req);\n        emit DataRequestedBool(requestId);\n    }\n\n    function requestBytes32Data(\n        uint32 _callbackGasLimit,\n        bytes32 _jobId\n    ) external returns (uint256 requestId) {\n        ADCS.Request memory req = buildRequest(_jobId, keccak256(abi.encodePacked(\"bytes32\")));\n        requestId = COORDINATOR.requestData(_callbackGasLimit, req);\n        emit DataRequestedBytes32(requestId);\n    }\n\n    function requestBytesData(\n        uint32 _callbackGasLimit,\n        bytes32 _jobId\n    ) external returns (uint256 requestId) {\n        ADCS.Request memory req = buildRequest(_jobId, keccak256(abi.encodePacked(\"bytes\")));\n        requestId = COORDINATOR.requestData(_callbackGasLimit, req);\n        emit DataRequestedBytes(requestId);\n    }\n\n    function fulfillDataRequest(uint256, uint256 response) internal virtual override {\n        lastUint256 = response;\n    }\n\n    function fulfillDataRequest(uint256, bool response) internal virtual override {\n        lastBool = response;\n    }\n\n    function fulfillDataRequest(uint256, bytes32 response) internal virtual override {\n        lastBytes32 = response;\n    }\n\n    function fulfillDataRequest(uint256, bytes memory response) internal virtual override {\n        lastBytes = response;\n    }\n}\n"
    },
    "src/mock/MockADCSConsumerArray.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../ADCSConsumerFulfill.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Define a struct to hold the array data\nstruct CoinData {\n    string symbol;\n    bool signal;\n}\n\ncontract MockADCSConsumerArray is ADCSConsumerFulfillBytes, Ownable {\n    using ADCS for ADCS.Request;\n\n    // Store the last received response\n    bytes public lastResponse;\n    uint256 public lastRequestId;\n    CoinData public lastDecodedData;\n\n    event DataRequested(uint256 indexed requestId);\n    event DataFulfilled(uint256 indexed requestId, string symbol, bool signal);\n\n    constructor(address coordinator) ADCSConsumerBase(coordinator) Ownable(msg.sender) {}\n\n    // Function to request array data\n    function requestArrayData(\n        bytes32 jobId,\n        uint32 callbackGasLimit,\n        string memory _from\n    ) external onlyOwner returns (uint256 requestId) {\n        bytes32 typeId = keccak256(abi.encodePacked(\"bytes\"));\n        ADCS.Request memory req = buildRequest(jobId, typeId);\n        req.add(\"from\", _from);\n        requestId = COORDINATOR.requestData(callbackGasLimit, req);\n        emit DataRequested(requestId);\n        return requestId;\n    }\n\n    // Implementation of the fulfill function for bytes\n    function fulfillDataRequest(uint256 requestId, bytes memory response) internal override {\n        lastRequestId = requestId;\n        lastResponse = response;\n\n        // Decode the response into CoinData struct\n        (string memory symbol, bool signal) = abi.decode(response, (string, bool));\n        lastDecodedData = CoinData(symbol, signal);\n\n        emit DataFulfilled(requestId, symbol, signal);\n    }\n\n    // Helper function to encode CoinData\n    function encodeCoinData(\n        string memory symbol,\n        bool signal\n    ) external pure returns (bytes memory) {\n        return abi.encode(symbol, signal);\n    }\n\n    // Helper function to decode CoinData\n    function decodeCoinData(\n        bytes memory data\n    ) external pure returns (string memory symbol, bool signal) {\n        return abi.decode(data, (string, bool));\n    }\n\n    // Helper function to get the last decoded data\n    function getLastDecodedData() external view returns (string memory symbol, bool signal) {\n        return (lastDecodedData.symbol, lastDecodedData.signal);\n    }\n}\n"
    },
    "src/mock/MockADCSConsumerBytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../ADCSConsumerFulfill.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MockADCSConsumerBytes is ADCSConsumerFulfillBytes, Ownable {\n    using ADCS for ADCS.Request;\n\n    // Store the last received response for testing\n    bytes public lastResponse;\n    uint256 public lastRequestId;\n\n    event DataRequested(uint256 indexed requestId);\n    event DataFulfilled(uint256 indexed requestId, bytes response);\n\n    constructor(address coordinator) ADCSConsumerBase(coordinator) Ownable(msg.sender) {}\n\n    // Function to request bytes data\n    function requestBytesData(\n        bytes32 jobId,\n        uint32 callbackGasLimit,\n        string memory _from\n    ) external onlyOwner returns (uint256 requestId) {\n        bytes32 typeId = keccak256(abi.encodePacked(\"bytes32\"));\n        ADCS.Request memory req = buildRequest(jobId, typeId);\n        req.add(\"from\", _from);\n        requestId = COORDINATOR.requestData(callbackGasLimit, req);\n        emit DataRequested(requestId);\n        return requestId;\n    }\n\n    // Implementation of the fulfill function for bytes\n    function fulfillDataRequest(uint256 requestId, bytes memory response) internal override {\n        lastRequestId = requestId;\n        lastResponse = response;\n        emit DataFulfilled(requestId, response);\n    }\n\n    // Helper function to get the typeId for bytes\n    function getTypeId() external pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"bytes\"));\n    }\n}\n"
    },
    "src/mock/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MockERC20 is ERC20, Ownable {\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply\n    ) ERC20(name, symbol) Ownable(msg.sender) {\n        _mint(msg.sender, initialSupply);\n    }\n\n    function mint(address to, uint256 amount) external onlyOwner {\n        _mint(to, amount);\n    }\n}\n"
    },
    "src/mock/MockTradeMemeCoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../ADCSConsumerFulfill.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/IPeripheryPayments.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockTradeMemeCoin is ADCSConsumerFulfillStringAndBool, Ownable {\n    using ADCS for ADCS.Request;\n\n    // Store the last received response for testing\n    bytes public lastResponse;\n    uint256 public lastRequestId;\n    uint256 public wethAmountForTrade = 1000000000000000; // 0.001 WETH\n    uint256 public memeCoinAmount = 100; // 100 memecoin\n\n    struct MemeCoin {\n        string name;\n        address addr;\n        uint8 decimals;\n    }\n\n    MemeCoin[] public memeCoins;\n\n    event DataRequested(uint256 indexed requestId);\n    event DataFulfilled(uint256 indexed requestId, bytes response);\n    event MemecoinNotFound(string tokenName);\n    event TradeSuccess(uint256 indexed requestId, uint256 amountIn, bool isBuy);\n\n    address public immutable WETH;\n    ISwapRouter public immutable swapRouter;\n\n    constructor(\n        address _coordinator,\n        address _weth,\n        address _swapRouter\n    ) ADCSConsumerBase(_coordinator) Ownable(msg.sender) {\n        WETH = _weth;\n        swapRouter = ISwapRouter(_swapRouter);\n    }\n\n    function setWethAmountForTrade(uint256 amount) external onlyOwner {\n        wethAmountForTrade = amount;\n    }\n\n    /**\n     * @notice Add a new memecoin to the list\n     * @param name The name of the memecoin\n     * @param addr The contract address of the memecoin\n     * @param decimals The decimals of the memecoin\n     */\n    function addMemeCoin(string memory name, address addr, uint8 decimals) external onlyOwner {\n        memeCoins.push(MemeCoin({name: name, addr: addr, decimals: decimals}));\n    }\n\n    /**\n     * @notice Get the total number of memecoins in the list\n     * @return The length of the memecoins array\n     */\n    function getMemeCoinCount() external view returns (uint256) {\n        return memeCoins.length;\n    }\n\n    /**\n     * @notice Get a memecoin by index\n     * @param index The index in the memecoins array\n     * @return name The memecoin name\n     * @return addr The memecoin contract address\n     * @return decimals The decimals of the memecoin\n     */\n    function getMemeCoin(\n        uint256 index\n    ) external view returns (string memory name, address addr, uint8 decimals) {\n        require(index < memeCoins.length, \"Index out of bounds\");\n        MemeCoin memory coin = memeCoins[index];\n        return (coin.name, coin.addr, coin.decimals);\n    }\n\n    // Function to request bytes data\n    function requestTradeMemeCoin(\n        bytes32 jobId,\n        uint256 callbackGasLimit\n    ) external returns (uint256 requestId) {\n        bytes32 typeId = keccak256(abi.encodePacked(\"stringAndbool\"));\n        ADCS.Request memory req = buildRequest(jobId, typeId);\n        requestId = COORDINATOR.requestData(callbackGasLimit, req);\n        emit DataRequested(requestId);\n        return requestId;\n    }\n\n    function fulfillDataRequest(\n        uint256 requestId,\n        StringAndBool memory response\n    ) internal virtual override {\n        string memory tokenName = response.name;\n        bool result = response.response;\n        // Find memecoin address and decimals by name\n        tradeMemeCoin(requestId, tokenName, result);\n    }\n\n    function tradeMemeCoin(uint256 requestId, string memory tokenName, bool result) internal {\n        // Find memecoin address and decimals by name\n        address memeTokenAddress;\n        uint8 tokenDecimals;\n        for (uint i = 0; i < memeCoins.length; i++) {\n            if (keccak256(bytes(memeCoins[i].name)) == keccak256(bytes(tokenName))) {\n                memeTokenAddress = memeCoins[i].addr;\n                tokenDecimals = memeCoins[i].decimals;\n                break;\n            }\n        }\n        if (memeTokenAddress == address(0)) {\n            emit MemecoinNotFound(tokenName);\n            return;\n        }\n\n        // Execute trade through Uniswap V3\n        if (result) {\n            // buy memecoin with eth\n            IERC20(WETH).approve(address(swapRouter), wethAmountForTrade);\n            swapRouter.exactInputSingle(\n                ISwapRouter.ExactInputSingleParams({\n                    tokenIn: WETH,\n                    tokenOut: memeTokenAddress,\n                    fee: 3000,\n                    recipient: address(this),\n                    deadline: block.timestamp + 15 minutes,\n                    amountIn: wethAmountForTrade,\n                    amountOutMinimum: 0,\n                    sqrtPriceLimitX96: 0\n                })\n            );\n\n            emit TradeSuccess(requestId, wethAmountForTrade, true);\n        } else {\n            // sell memecoin for eth\n            // First approve router to spend our tokens\n            uint256 memeCoinAmountInWei = memeCoinAmount * (10 ** tokenDecimals);\n            IERC20(memeTokenAddress).approve(address(swapRouter), memeCoinAmountInWei);\n\n            swapRouter.exactInputSingle(\n                ISwapRouter.ExactInputSingleParams({\n                    tokenIn: memeTokenAddress, // memecoin token\n                    tokenOut: WETH, // eth\n                    fee: 3000, // 0.3% fee tier\n                    recipient: address(this),\n                    deadline: block.timestamp + 15 minutes,\n                    amountIn: memeCoinAmountInWei,\n                    amountOutMinimum: 0, // Set minimum amount out to 0 (should use proper slippage in production)\n                    sqrtPriceLimitX96: 0\n                })\n            );\n            emit TradeSuccess(requestId, memeCoinAmountInWei, false);\n        }\n    }\n\n    function tradeMemeCoinV2(uint256 requestId, string memory tokenName, bool result) internal {\n        // Find memecoin address and decimals by name\n        address memeTokenAddress;\n        uint8 tokenDecimals;\n        for (uint i = 0; i < memeCoins.length; i++) {\n            if (keccak256(bytes(memeCoins[i].name)) == keccak256(bytes(tokenName))) {\n                memeTokenAddress = memeCoins[i].addr;\n                tokenDecimals = memeCoins[i].decimals;\n                break;\n            }\n        }\n        if (memeTokenAddress == address(0)) {\n            emit MemecoinNotFound(tokenName);\n            return;\n        }\n\n        // Execute trade through Uniswap V2\n        if (result) {\n            // buy memecoin with eth\n            IERC20(WETH).approve(address(swapRouter), wethAmountForTrade);\n            swapRouter.exactInputSingle(\n                ISwapRouter.ExactInputSingleParams({\n                    tokenIn: WETH,\n                    tokenOut: memeTokenAddress,\n                    fee: 3000,\n                    recipient: address(this),\n                    deadline: block.timestamp + 15 minutes,\n                    amountIn: wethAmountForTrade,\n                    amountOutMinimum: 0,\n                    sqrtPriceLimitX96: 0\n                })\n            );\n\n            emit TradeSuccess(requestId, wethAmountForTrade, true);\n        } else {\n            // sell memecoin for eth\n            // First approve router to spend our tokens\n            uint256 memeCoinAmountInWei = memeCoinAmount * (10 ** tokenDecimals);\n            IERC20(memeTokenAddress).approve(address(swapRouter), memeCoinAmountInWei);\n\n            swapRouter.exactInputSingle(\n                ISwapRouter.ExactInputSingleParams({\n                    tokenIn: memeTokenAddress, // memecoin token\n                    tokenOut: WETH, // eth\n                    fee: 3000, // 0.3% fee tier\n                    recipient: address(this),\n                    deadline: block.timestamp + 15 minutes,\n                    amountIn: memeCoinAmountInWei,\n                    amountOutMinimum: 0, // Set minimum amount out to 0 (should use proper slippage in production)\n                    sqrtPriceLimitX96: 0\n                })\n            );\n            emit TradeSuccess(requestId, memeCoinAmountInWei, false);\n        }\n    }\n\n    receive() external payable {}\n\n    function withdraw() external onlyOwner {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function withdrawToken(address token) external onlyOwner {\n        IERC20(token).transfer(owner(), IERC20(token).balanceOf(address(this)));\n    }\n}\n"
    },
    "src/mock/MockTradeMemeCoinV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"../ADCSConsumerFulfill.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@uniswap/swap-router-contracts/contracts/interfaces/IV3SwapRouter.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockTradeMemeCoinV2 is ADCSConsumerFulfillStringAndBool, Ownable {\n    using ADCS for ADCS.Request;\n\n    // Store the last received response for testing\n    bytes public lastResponse;\n    uint256 public lastRequestId;\n    uint256 public wethAmountForTrade = 1000000000000000; // 0.001 WETH\n    uint256 public memeCoinAmount = 100; // 100 memecoin\n\n    struct MemeCoin {\n        string name;\n        address addr;\n        uint8 decimals;\n    }\n\n    MemeCoin[] public memeCoins;\n\n    event DataRequested(uint256 indexed requestId);\n    event DataFulfilled(uint256 indexed requestId, bytes response);\n    event MemecoinNotFound(string tokenName);\n    event TradeSuccess(uint256 indexed requestId, uint256 amountIn, bool isBuy);\n\n    address public immutable WETH;\n    IV3SwapRouter public swapRouter;\n\n    constructor(\n        address _coordinator,\n        address _weth,\n        address _swapRouter\n    ) ADCSConsumerBase(_coordinator) Ownable(msg.sender) {\n        WETH = _weth;\n        swapRouter = IV3SwapRouter(_swapRouter);\n    }\n\n    function setWethAmountForTrade(uint256 amount) external onlyOwner {\n        wethAmountForTrade = amount;\n    }\n\n    /**\n     * @notice Add a new memecoin to the list\n     * @param name The name of the memecoin\n     * @param addr The contract address of the memecoin\n     * @param decimals The decimals of the memecoin\n     */\n    function addMemeCoin(string memory name, address addr, uint8 decimals) external onlyOwner {\n        memeCoins.push(MemeCoin({name: name, addr: addr, decimals: decimals}));\n    }\n\n    function setTokenAmount(uint256 _newAmount) external onlyOwner {\n        memeCoinAmount = _newAmount;\n    }\n\n    function setSwapRouter(address _swapRouter) external onlyOwner {\n        swapRouter = IV3SwapRouter(_swapRouter);\n    }\n\n    /**\n     * @notice Get the total number of memecoins in the list\n     * @return The length of the memecoins array\n     */\n    function getMemeCoinCount() external view returns (uint256) {\n        return memeCoins.length;\n    }\n\n    /**\n     * @notice Get a memecoin by index\n     * @param index The index in the memecoins array\n     * @return name The memecoin name\n     * @return addr The memecoin contract address\n     * @return decimals The decimals of the memecoin\n     */\n    function getMemeCoin(\n        uint256 index\n    ) external view returns (string memory name, address addr, uint8 decimals) {\n        require(index < memeCoins.length, \"Index out of bounds\");\n        MemeCoin memory coin = memeCoins[index];\n        return (coin.name, coin.addr, coin.decimals);\n    }\n\n    // Function to request bytes data\n    function requestTradeMemeCoin(\n        bytes32 jobId,\n        uint256 callbackGasLimit\n    ) external returns (uint256 requestId) {\n        bytes32 typeId = keccak256(abi.encodePacked(\"stringAndbool\"));\n        ADCS.Request memory req = buildRequest(jobId, typeId);\n        requestId = COORDINATOR.requestData(callbackGasLimit, req);\n        emit DataRequested(requestId);\n        return requestId;\n    }\n\n    function fulfillDataRequest(\n        uint256 requestId,\n        StringAndBool memory response\n    ) internal virtual override {\n        string memory tokenName = response.name;\n        bool result = response.response;\n        // Find memecoin address and decimals by name\n        tradeMemeCoin(requestId, tokenName, result);\n    }\n\n    function tradeMemeCoin(uint256 requestId, string memory tokenName, bool result) internal {\n        // Find memecoin address and decimals by name\n        address memeTokenAddress;\n        uint8 tokenDecimals;\n        for (uint i = 0; i < memeCoins.length; i++) {\n            if (keccak256(bytes(memeCoins[i].name)) == keccak256(bytes(tokenName))) {\n                memeTokenAddress = memeCoins[i].addr;\n                tokenDecimals = memeCoins[i].decimals;\n                break;\n            }\n        }\n        if (memeTokenAddress == address(0)) {\n            emit MemecoinNotFound(tokenName);\n            return;\n        }\n\n        // Execute trade through Uniswap V3\n        if (result) {\n            // buy memecoin with eth\n            IERC20(WETH).approve(address(swapRouter), wethAmountForTrade);\n            swapRouter.exactInputSingle(\n                IV3SwapRouter.ExactInputSingleParams({\n                    tokenIn: WETH,\n                    tokenOut: memeTokenAddress,\n                    fee: 3000,\n                    recipient: address(this),\n                    amountIn: wethAmountForTrade,\n                    amountOutMinimum: 0,\n                    sqrtPriceLimitX96: 0\n                })\n            );\n\n            emit TradeSuccess(requestId, wethAmountForTrade, true);\n        } else {\n            // sell memecoin for eth\n            // First approve router to spend our tokens\n            uint256 memeCoinAmountInWei = memeCoinAmount * (10 ** tokenDecimals);\n            IERC20(memeTokenAddress).approve(address(swapRouter), memeCoinAmountInWei);\n\n            swapRouter.exactInputSingle(\n                IV3SwapRouter.ExactInputSingleParams({\n                    tokenIn: memeTokenAddress, // memecoin token\n                    tokenOut: WETH, // eth\n                    fee: 3000, // 0.3% fee tier\n                    recipient: address(this),\n                    amountIn: memeCoinAmountInWei,\n                    amountOutMinimum: 0, // Set minimum amount out to 0 (should use proper slippage in production)\n                    sqrtPriceLimitX96: 0\n                })\n            );\n            emit TradeSuccess(requestId, memeCoinAmountInWei, false);\n        }\n    }\n\n    receive() external payable {}\n\n    function withdraw() external onlyOwner {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function withdrawToken(address token) external onlyOwner {\n        IERC20(token).transfer(owner(), IERC20(token).balanceOf(address(this)));\n    }\n}\n"
    },
    "src/mock/MockUniswapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockUniswapRouter {\n    event SwapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] path,\n        address to,\n        uint deadline\n    );\n\n    function exactInputSingle(\n        ExactInputSingleParams calldata params\n    ) external payable returns (uint256 amountOut) {\n        // Transfer tokens from sender to simulate swap\n        IERC20(params.tokenIn).transferFrom(msg.sender, address(this), params.amountIn);\n        IERC20(params.tokenOut).transfer(params.recipient, params.amountOut);\n\n        return params.amountOut;\n    }\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOut;\n        uint160 sqrtPriceLimitX96;\n    }\n}\n"
    },
    "src/mock/test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract TestAdcs {\n    event DataRequested(\n        uint256 indexed requestId,\n        uint256 callbackGasLimit,\n        address indexed sender,\n        bytes32 jobId,\n        uint256 blockNumber,\n        bytes data\n    );\n\n    constructor() {}\n\n    function requestData(\n        uint256 requestId,\n        uint256 callbackGasLimit,\n        bytes32 jobId,\n        bytes memory data\n    ) external {\n        emit DataRequested(requestId, callbackGasLimit, msg.sender, jobId, block.number, data);\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}